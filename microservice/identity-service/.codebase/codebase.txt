/* ===== identity_service/config/ApplicationInitConfig.java ===== */
package com.hau.identity_service.config;

import java.util.HashSet;
import java.util.Set;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.ApplicationRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.password.PasswordEncoder;

import com.hau.identity_service.entity.Role;
import com.hau.identity_service.entity.User;
import com.hau.identity_service.repository.RoleRepository;
import com.hau.identity_service.repository.UserRepository;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@RequiredArgsConstructor
@Configuration
@Slf4j
public class ApplicationInitConfig {

    private final PasswordEncoder passwordEncoder;

    @Value("${admin.username}")
    private String adminUsername;

    @Value("${admin.password}")
    private String adminPassword;

    @Value("${admin.role}")
    private String adminRole;

    @Bean
    ApplicationRunner applicationRunner(UserRepository userRepository, RoleRepository roleRepository) {
        return args -> {
            if (roleRepository.findByName(adminRole).isEmpty()) {
                Role role = Role.builder()
                        .name(adminRole)
                        .description("Quyền quản trị viên")
                        .build();
                roleRepository.save(role);
                log.info("Role ADMIN đã được tạo.");
            }

            if (roleRepository.findByName("USER").isEmpty()) {
                Role userRole = Role.builder()
                        .name("USER")
                        .description("Quyền người dùng")
                        .build();
                roleRepository.save(userRole);
                log.info("Role USER đã được tạo.");
            }

            if (roleRepository.findByName("STAFF").isEmpty()) {
                Role userRole = Role.builder()
                        .name("STAFF")
                        .description("Quyền nhân viên")
                        .build();
                roleRepository.save(userRole);
                log.info("Role STAFF đã được tạo.");
            }

            if (userRepository.findByUsername(adminUsername).isEmpty()) {

                User user = User.builder()
                        .username(adminUsername)
                        .password(passwordEncoder.encode(adminPassword))
                        .email("datdnk3@gmail.com")
                        .build();
                var roles = roleRepository.findAllById(Set.of(adminRole));
                if (roles.isEmpty()) {
                    log.error("Không tìm thấy role ADMIN");
                    return;
                }
                user.setRoles(new HashSet<>(roles));
                userRepository.save(user);
                log.warn(
                        "Người dùng admin đã được tạo với mật khẩu là admin, hãy thay đổi mật khẩu ngay sau khi đăng nhập lần đầu tiên");
            }
        };
    }
}


/* ===== identity_service/config/AuthenticationRequestInterceptor.java ===== */
package com.hau.identity_service.config;

import feign.RequestInterceptor;
import feign.RequestTemplate;
import lombok.extern.slf4j.Slf4j;
import org.springframework.util.StringUtils;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

@Slf4j
public class AuthenticationRequestInterceptor implements RequestInterceptor {
    @Override
    public void apply(RequestTemplate requestTemplate) {
        ServletRequestAttributes servletRequestAttributes =
                (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();

        assert servletRequestAttributes != null;
        var authHeader = servletRequestAttributes.getRequest().getHeader("Authorization");
        log.info("Auth header: {}", authHeader);
        if (StringUtils.hasText(authHeader) && authHeader.startsWith("Bearer ")) {
            requestTemplate.header("Authorization", authHeader);
        } else {
            log.warn("No Authorization header found in the request");
        }
    }
}


/* ===== identity_service/config/CustomJwtDecoder.java ===== */
package com.hau.identity_service.config;

import java.text.ParseException;

import com.nimbusds.jwt.SignedJWT;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.stereotype.Component;

import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class CustomJwtDecoder implements JwtDecoder {
    @Override
    public Jwt decode(String token) throws JwtException {
        try {
            SignedJWT signedJWT = SignedJWT.parse(token);
            return new Jwt(token, signedJWT.getJWTClaimsSet().getIssueTime().toInstant(),
                    signedJWT.getJWTClaimsSet().getExpirationTime().toInstant(),
                    signedJWT.getHeader().toJSONObject(),
                    signedJWT.getJWTClaimsSet().getClaims()
                    );
        } catch (ParseException e) {
            throw new JwtException("Failed to parse JWT", e);
        }
    }
}


/* ===== identity_service/config/FeignMultipartSupportConfig.java ===== */
package com.hau.identity_service.config;

import feign.codec.Encoder;
import feign.form.spring.SpringFormEncoder;
import org.springframework.boot.autoconfigure.http.HttpMessageConverters;
import org.springframework.cloud.openfeign.support.SpringEncoder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class FeignMultipartSupportConfig {
    @Bean
    public Encoder feignFormEncoder() {
        return new SpringFormEncoder(new SpringEncoder(() -> new HttpMessageConverters(new RestTemplate().getMessageConverters())));
    }
}


/* ===== identity_service/config/JwtAuthenticationEntryPoint.java ===== */
package com.hau.identity_service.config;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.hau.identity_service.dto.response.ApiResponse;

public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(
            HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)
            throws IOException {
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding(StandardCharsets.UTF_8.name());

        ApiResponse<?> apiResponse = ApiResponse.builder()
                .status(HttpStatus.UNAUTHORIZED.value())
                .message("Không có quyền truy cập")
                .timestamp(LocalDateTime.now())
                .build();

        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        response.getWriter().write(objectMapper.writeValueAsString(apiResponse));
        response.flushBuffer();
    }
}


/* ===== identity_service/config/SecurityConfig.java ===== */
package com.hau.identity_service.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.SecurityFilterChain;

import lombok.RequiredArgsConstructor;

@Configuration
@EnableMethodSecurity
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final String[] publicPostEndpoint = {
            "/users/register",
            "/auth/**",
    };

    private final CustomJwtDecoder customJwtDecoder;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
//        http.cors(cors -> cors.configurationSource(request -> {
//            CorsConfiguration config = new CorsConfiguration();
//            config.addAllowedOrigin("*");
//            config.addAllowedMethod("*");
//            config.addAllowedHeader("*");
//            config.setAllowCredentials(false);
//            config.setMaxAge(3600L);
//            return config;
//        }));

        http.authorizeHttpRequests(request -> request
                .requestMatchers(HttpMethod.POST, publicPostEndpoint)
                .permitAll()
                .anyRequest()
                .authenticated());

        http.oauth2ResourceServer(oauth2 -> oauth2.jwt(jwtConfigurer -> jwtConfigurer
                        .decoder(customJwtDecoder)
                        .jwtAuthenticationConverter(jwtAuthenticationConverter()))
                .authenticationEntryPoint(new JwtAuthenticationEntryPoint()));

        http.csrf(AbstractHttpConfigurer::disable);
        return http.build();
    }

    @Bean
    JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
        jwtGrantedAuthoritiesConverter.setAuthorityPrefix("");
        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);

        return jwtAuthenticationConverter;
    }

    @Bean
    PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(10);
    }
}

/* ===== identity_service/controller/AuthenticationController.java ===== */
package com.hau.identity_service.controller;

import java.text.ParseException;

import jakarta.validation.Valid;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import com.hau.identity_service.dto.request.*;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.AuthenticationResponse;
import com.hau.identity_service.dto.response.IntrospectResponse;
import com.hau.identity_service.dto.response.VerifyOtpResponse;
import com.hau.identity_service.service.AuthenticationService;
import com.hau.identity_service.service.ForgotPasswordService;
import com.hau.identity_service.service.TokenService;
import com.nimbusds.jose.JOSEException;

import lombok.RequiredArgsConstructor;

@RestController
@RequiredArgsConstructor
@RequestMapping("/auth")
public class AuthenticationController {
    private final AuthenticationService authenticationService;
    private final ForgotPasswordService forgotPasswordService;
    private final TokenService tokenService;

    @PostMapping("/login")
    public ResponseEntity<ApiResponse<AuthenticationResponse>> authenticate(
            @RequestBody @Valid AuthenticationRequest authenticationRequest) {
        ApiResponse<AuthenticationResponse> apiResponse = authenticationService.authenticate(authenticationRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PostMapping("/logout")
    public ResponseEntity<ApiResponse<Void>> logout(@RequestBody LogoutRequest logoutRequest) throws ParseException {
        ApiResponse<Void> apiResponse = authenticationService.logout(logoutRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PostMapping("/refresh-token")
    public ResponseEntity<ApiResponse<AuthenticationResponse>> refreshToken(
            @RequestBody RefreshTokenRequest refreshTokenRequest) throws ParseException, JOSEException {
        ApiResponse<AuthenticationResponse> apiResponse = tokenService.refreshToken(refreshTokenRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PostMapping("/introspect")
    public ResponseEntity<ApiResponse<IntrospectResponse>> introspect(@RequestBody IntrospectRequest request) {
        ApiResponse<IntrospectResponse> apiResponse = authenticationService.introspect(request);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PostMapping("/password-recovery/otp")
    public ResponseEntity<ApiResponse<String>> sendOtpForgotPassword(
            @RequestBody @Valid ForgotPasswordRequest forgotPasswordRequest) {
        ApiResponse<String> apiResponse = forgotPasswordService.sendOtp(forgotPasswordRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PostMapping("/password-recovery/otp/verify")
    public ResponseEntity<ApiResponse<VerifyOtpResponse>> verifyOtpForgotPassword(
            @Valid @RequestBody VerifyOtpRequest verifyOtpRequest) {
        ApiResponse<VerifyOtpResponse> apiResponse = forgotPasswordService.verifyOtp(verifyOtpRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PostMapping("/password-recovery/reset")
    public ResponseEntity<ApiResponse<String>> resetPassword(
            @Valid @RequestBody ResetPasswordWithTokenRequest resetPasswordWithTokenRequest) {
        ApiResponse<String> apiResponse = forgotPasswordService.resetPassword(resetPasswordWithTokenRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }
}


/* ===== identity_service/controller/PermissionController.java ===== */
package com.hau.identity_service.controller;

import java.util.List;

import jakarta.validation.Valid;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import com.hau.identity_service.dto.request.PermissionCreationRequest;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.PermissionResponse;
import com.hau.identity_service.service.PermissionService;

import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/permissions")
@RequiredArgsConstructor
public class PermissionController {
    private final PermissionService permissionService;

    @PreAuthorize("hasRole('ADMIN')")
    @PostMapping
    public ResponseEntity<ApiResponse<PermissionResponse>> createPermission(
            @RequestBody @Valid PermissionCreationRequest permissionCreationRequest) {
        ApiResponse<PermissionResponse> apiResponse = permissionService.createPermission(permissionCreationRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN')")
    @GetMapping
    public ResponseEntity<ApiResponse<List<PermissionResponse>>> getAllPermissions() {
        ApiResponse<List<PermissionResponse>> apiResponse = permissionService.getAllPermissions();
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN')")
    @DeleteMapping("/{name}")
    public ResponseEntity<ApiResponse<PermissionResponse>> deletePermission(@PathVariable String name) {
        ApiResponse<PermissionResponse> apiResponse = permissionService.deletePermission(name);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }
}


/* ===== identity_service/controller/RoleController.java ===== */
package com.hau.identity_service.controller;

import java.util.List;

import jakarta.validation.Valid;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import com.hau.identity_service.dto.request.RoleCreationRequest;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.RoleResponse;
import com.hau.identity_service.service.RoleService;

import lombok.RequiredArgsConstructor;

@RestController
@RequiredArgsConstructor
@RequestMapping("/roles")
public class RoleController {
    private final RoleService roleService;

    @PreAuthorize("hasRole('ADMIN')")
    @PostMapping
    public ResponseEntity<ApiResponse<RoleResponse>> createRole(@RequestBody @Valid RoleCreationRequest roleRequest) {
        ApiResponse<RoleResponse> apiResponse = roleService.createRole(roleRequest);
        return new ResponseEntity<>(apiResponse, HttpStatus.CREATED);
    }

    @PreAuthorize("hasRole('ADMIN')")
    @GetMapping
    public ResponseEntity<ApiResponse<List<RoleResponse>>> getAllRoles() {
        ApiResponse<List<RoleResponse>> apiResponse = roleService.getAllRoles();
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN')")
    @DeleteMapping("/{name}")
    public ResponseEntity<ApiResponse<RoleResponse>> deleteRole(@PathVariable String name) {
        ApiResponse<RoleResponse> apiResponse = roleService.deleteRole(name);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }
}


/* ===== identity_service/controller/UserController.java ===== */
package com.hau.identity_service.controller;

import com.hau.identity_service.dto.response.PageResponse;
import jakarta.validation.Valid;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import com.hau.identity_service.dto.request.ChangePasswordRequest;
import com.hau.identity_service.dto.request.UserCreateRequest;
import com.hau.identity_service.dto.request.UserUpdateInfoRequest;
import com.hau.identity_service.dto.request.UserUpdateRequest;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.UserResponse;
import com.hau.identity_service.service.UserService;

import lombok.RequiredArgsConstructor;
import org.springframework.web.multipart.MultipartFile;

@RestController
@RequiredArgsConstructor
@RequestMapping("/users")
public class UserController {
    private final UserService userService;

    @PostMapping("/register")
    public ResponseEntity<ApiResponse<UserResponse>> createUser(
            @Valid @RequestBody UserCreateRequest userCreateRequest) {
        ApiResponse<UserResponse> userResponse = userService.createUser(userCreateRequest);
        return new ResponseEntity<>(userResponse, HttpStatus.CREATED);
    }

    @PutMapping("/profile-image")
    public ResponseEntity<ApiResponse<UserResponse>> updateUserProfileImage(
            @RequestParam("profileImage") MultipartFile profileImage) {
        ApiResponse<UserResponse> userResponse = userService.updateUserProfileImage(profileImage);
        return new ResponseEntity<>(userResponse, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN') or hasRole('STAFF') or @userService.isOwnerOfUser(#userId, authentication)")
    @GetMapping("/{userId}")
    public ResponseEntity<ApiResponse<UserResponse>> getUserById(@PathVariable Long userId) {
        ApiResponse<UserResponse> userResponse = userService.getUserById(userId);
        return new ResponseEntity<>(userResponse, HttpStatus.OK);
    }

    @GetMapping("/info")
    public ResponseEntity<ApiResponse<UserResponse>> myInfo() {
        ApiResponse<UserResponse> userResponse = userService.myInfo();
        return new ResponseEntity<>(userResponse, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN') or hasRole('STAFF')")
    @PutMapping("/{userId}")
    public ResponseEntity<ApiResponse<UserResponse>> updateUser(
            @PathVariable Long userId, @Valid @RequestBody UserUpdateRequest userUpdateRequest) {
        ApiResponse<UserResponse> userResponse = userService.updateUser(userId, userUpdateRequest);
        return new ResponseEntity<>(userResponse, HttpStatus.OK);
    }

    @PutMapping("/info")
    public ResponseEntity<ApiResponse<UserResponse>> updateUserInfo(@Valid @RequestBody UserUpdateInfoRequest userUpdateInfoRequest) {
        ApiResponse<UserResponse> userResponse = userService.updateUserInfo(userUpdateInfoRequest);
        return new ResponseEntity<>(userResponse, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN') or hasRole('STAFF') or @userService.isOwnerOfUser(#userId, authentication)")
    @PatchMapping("/{userId}/password")
    public ResponseEntity<ApiResponse<UserResponse>> updatePassword(
            @PathVariable Long userId, @RequestBody @Valid ChangePasswordRequest changePasswordRequest) {
        ApiResponse<UserResponse> userResponse = userService.changePassword(userId, changePasswordRequest);
        return new ResponseEntity<>(userResponse, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN') or hasRole('STAFF')")
    @GetMapping
    public ResponseEntity<ApiResponse<PageResponse<UserResponse>>> getAllUsers(
            @RequestParam(required = false, defaultValue = "1") int pageIndex,
            @RequestParam(required = false, defaultValue = "10") int pageSize
    ) {
        ApiResponse<PageResponse<UserResponse>> userPage = userService.getAllUsers(pageIndex, pageSize);
        return new ResponseEntity<>(userPage, HttpStatus.OK);
    }

    @PreAuthorize("hasRole('ADMIN') or hasRole('STAFF')")
    @DeleteMapping("/{userId}")
    public ResponseEntity<ApiResponse<UserResponse>> deleteUser(@PathVariable Long userId) {
        ApiResponse<UserResponse> userResponse = userService.deleteUser(userId);
        return new ResponseEntity<>(userResponse, HttpStatus.OK);
    }
}


/* ===== identity_service/dto/request/AuthenticationRequest.java ===== */
package com.hau.identity_service.dto.request;

import jakarta.validation.constraints.NotBlank;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AuthenticationRequest {
    @NotBlank(message = "Tên đăng nhập không được để trống")
    private String username;

    @NotBlank(message = "Mật khẩu không được để trống")
    private String password;
}


/* ===== identity_service/dto/request/CartCreateRequest.java ===== */
package com.hau.identity_service.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CartCreateRequest {
    private Integer id;
    private Integer userId;
}


/* ===== identity_service/dto/request/ChangePasswordRequest.java ===== */
package com.hau.identity_service.dto.request;

import jakarta.validation.constraints.NotBlank;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ChangePasswordRequest {
    @NotBlank(message = "Mật khẩu cũ không được để trống")
    private String oldPassword;

    @NotBlank(message = "Mật khẩu mới không được để trống")
    private String newPassword;
}


/* ===== identity_service/dto/request/ForgotPasswordRequest.java ===== */
package com.hau.identity_service.dto.request;

import jakarta.validation.constraints.NotBlank;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ForgotPasswordRequest {
    @NotBlank(message = "Tên đăng nhập không được để trống")
    private String username;
}


/* ===== identity_service/dto/request/IntrospectRequest.java ===== */
package com.hau.identity_service.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class IntrospectRequest {
    private String token;
}


/* ===== identity_service/dto/request/LogoutRequest.java ===== */
package com.hau.identity_service.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class LogoutRequest {
    private String token;
}


/* ===== identity_service/dto/request/PermissionCreationRequest.java ===== */
package com.hau.identity_service.dto.request;

import jakarta.validation.constraints.NotBlank;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PermissionCreationRequest {
    @NotBlank(message = "Tên quyền không được để trống")
    private String name;

    private String description;
}


/* ===== identity_service/dto/request/RefreshTokenRequest.java ===== */
package com.hau.identity_service.dto.request;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class RefreshTokenRequest {
    private String token;
}


/* ===== identity_service/dto/request/ResetPasswordWithTokenRequest.java ===== */
package com.hau.identity_service.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ResetPasswordWithTokenRequest {
    @NotBlank(message = "Mật khẩu không được để trống")
    @Size(min = 6, message = "Mật khẩu phải có ít nhất 6 ký tự")
    private String newPassword;

    @NotBlank(message = "Mã xác nhận không được để trống")
    private String verificationToken;
}


/* ===== identity_service/dto/request/RoleCreationRequest.java ===== */
package com.hau.identity_service.dto.request;

import java.util.Set;

import jakarta.validation.constraints.NotBlank;

import lombok.*;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RoleCreationRequest {
    @NotBlank(message = "Tên vai trò không được để trống")
    private String name;

    private String description;
    private Set<String> permissions;
}


/* ===== identity_service/dto/request/UserCreateRequest.java ===== */
package com.hau.identity_service.dto.request;

import java.util.Set;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserCreateRequest {
    @NotBlank(message = "Username không được để trống")
    @Pattern(regexp = "^[a-z0-9]+$", message = "Username chỉ được chứa chữ cái thường và không có ký tự đặc biệt")
    private String username;

    @Size(min = 6, message = "Password phải có ít nhất 6 ký tự")
    private String password;

    @Email(message = "Email không đúng định dạng")
    @NotBlank(message = "Email không được để trống")
    private String email;
    private Set<String> roles;
}


/* ===== identity_service/dto/request/UserUpdateImageRequest.java ===== */
package com.hau.identity_service.dto.request;

public class UserUpdateImageRequest {
}


/* ===== identity_service/dto/request/UserUpdateInfoRequest.java ===== */
package com.hau.identity_service.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserUpdateInfoRequest {
    @NotBlank(message = "Email không được để trống")
    @Email(message = "Email không đúng định dạng")
    private String email;
}


/* ===== identity_service/dto/request/UserUpdateRequest.java ===== */
package com.hau.identity_service.dto.request;

import java.util.Set;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserUpdateRequest {
    @Size(min = 6, message = "Password phải có ít nhất 6 ký tự")
    private String password;

    @NotBlank(message = "Email không được để trống")
    @Email(message = "Email không đúng định dạng")
    private String email;

    private Set<String> roles;
}


/* ===== identity_service/dto/request/VerifyOtpRequest.java ===== */
package com.hau.identity_service.dto.request;

import jakarta.validation.constraints.NotBlank;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class VerifyOtpRequest {
    @NotBlank(message = "Username không được để trống")
    private String username;

    private int otp;
}


/* ===== identity_service/dto/response/ApiResponse.java ===== */
package com.hau.identity_service.dto.response;

import java.time.LocalDateTime;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@JsonIgnoreProperties(ignoreUnknown = true)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
    private int status;
    private String message;
    private T result;
    private LocalDateTime timestamp;
}


/* ===== identity_service/dto/response/AuthenticationResponse.java ===== */
package com.hau.identity_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AuthenticationResponse {
    private boolean authenticated;
    private String token;
}


/* ===== identity_service/dto/response/CartResponse.java ===== */
package com.hau.identity_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CartResponse {
    private Integer id;
    private Integer userId;
}


/* ===== identity_service/dto/response/ErrorsResponse.java ===== */
package com.hau.identity_service.dto.response;

import java.time.LocalDateTime;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ErrorsResponse {
    private int status;
    private String message;
    private Object error;
    private LocalDateTime timestamp;
}


/* ===== identity_service/dto/response/FileResponse.java ===== */
package com.hau.identity_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class FileResponse {
    private String originalFileName;
    private String url;
}


/* ===== identity_service/dto/response/IntrospectResponse.java ===== */
package com.hau.identity_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class IntrospectResponse {
    private boolean valid;
    private String username;
}


/* ===== identity_service/dto/response/PageResponse.java ===== */
package com.hau.identity_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Collections;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PageResponse<T> {
    private int currentPage;
    private int totalPages;
    private long totalElements;
    private int pageSize;

    @Builder.Default
    private List<T> data = Collections.emptyList();
}


/* ===== identity_service/dto/response/PermissionResponse.java ===== */
package com.hau.identity_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PermissionResponse {
    private String name;
    private String description;
}


/* ===== identity_service/dto/response/RoleResponse.java ===== */
package com.hau.identity_service.dto.response;

import java.util.Set;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RoleResponse {
    private String name;
    private String description;
    private Set<PermissionResponse> permissions;
}


/* ===== identity_service/dto/response/UserResponse.java ===== */
package com.hau.identity_service.dto.response;

import java.util.Set;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.beans.factory.annotation.Value;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserResponse {
    private String id;
    private String username;
    private String email;
    private String profileImage;
    private Set<RoleResponse> roles;
}


/* ===== identity_service/dto/response/VerifyOtpResponse.java ===== */
package com.hau.identity_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class VerifyOtpResponse {
    private String verificationToken;
}


/* ===== identity_service/entity/InvalidatedToken.java ===== */
package com.hau.identity_service.entity;

import java.util.Date;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

import lombok.*;

@Builder
@Setter
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "invalidated_token")
public class InvalidatedToken {
    @Id
    private String id;

    private Date expiryDate;
}


/* ===== identity_service/entity/Permission.java ===== */
package com.hau.identity_service.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

import lombok.*;

@Entity
@Setter
@Getter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "permissions")
public class Permission {
    @Id
    private String name;

    private String description;
}


/* ===== identity_service/entity/Role.java ===== */
package com.hau.identity_service.entity;

import java.util.Set;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.Table;

import lombok.*;

@Entity
@Setter
@Getter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "roles")
public class Role {
    @Id
    private String name;

    private String description;

    @ManyToMany
    Set<Permission> permissions;
}


/* ===== identity_service/entity/User.java ===== */
package com.hau.identity_service.entity;

import java.time.LocalDateTime;
import java.util.Set;

import jakarta.persistence.*;

import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import lombok.*;

@Entity
@Setter
@Getter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Column(unique = true, length = 50)
    private String username;
    private String password;
    private String email;
    private String profileImage;

    @ManyToMany
    private Set<Role> roles;

    @CreationTimestamp
    private LocalDateTime createdAt;

    @UpdateTimestamp
    private LocalDateTime updatedAt;
}


/* ===== identity_service/exception/AppException.java ===== */
package com.hau.identity_service.exception;

import java.time.LocalDateTime;

import org.springframework.http.HttpStatus;

import lombok.Getter;
import lombok.Setter;

@Setter
@Getter
public class AppException extends RuntimeException {
    private final HttpStatus httpStatus;
    private final transient Object error;
    private final LocalDateTime timestamp;

    public AppException(HttpStatus httpStatus, String message, Object error) {
        super(message);
        this.httpStatus = httpStatus;
        this.error = error;
        this.timestamp = LocalDateTime.now();
    }
}


/* ===== identity_service/exception/GlobalExceptionHandler.java ===== */
package com.hau.identity_service.exception;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.security.authorization.AuthorizationDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;

import com.hau.identity_service.dto.response.ErrorsResponse;

@RestControllerAdvice
public class GlobalExceptionHandler {
    // Xử lý ngoại lệ validation
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorsResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            Map<String, String> detail = new HashMap<>();
            detail.put("field", error.getField());
            detail.put("message", error.getDefaultMessage());
            errorDetails.add(detail);
        });
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Lỗi trường dữ liệu", errorDetails, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ DataIntegrityViolationException
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorsResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        Map<String, String> detail = new HashMap<>();
        detail.put("error", ex.getMessage());
        errorDetails.add(detail);
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Vi phạm tính toàn vẹn dữ liệu. Xem 'error' để biết chi tiết.",
                errorDetails,
                LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ tham số không đúng định dạng trong url
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<ErrorsResponse> handleMethodArgumentTypeMismatch(MethodArgumentTypeMismatchException ex) {
        String name = ex.getName();
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Tham số " + name + " không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi truyền sai định dạng tham số trong body request
    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorsResponse> handleHttpMessageNotReadableException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Dữ liệu request không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi khi không tìm thấy tài nguyên
    @ExceptionHandler(AppException.class)
    public ResponseEntity<ErrorsResponse> handleAppException(AppException ex) {
        ErrorsResponse errorResponse =
                new ErrorsResponse(ex.getHttpStatus().value(), ex.getMessage(), ex.getError(), LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, ex.getHttpStatus()); // Trả về HttpStatus từ AppException
    }

    // Xử lý lỗi không có quyền truy cập
    @ExceptionHandler(AuthorizationDeniedException.class)
    public ResponseEntity<ErrorsResponse> handleAccessDeniedException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.FORBIDDEN.value(), "Không có quyền truy cập tài nguyên này", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.FORBIDDEN);
    }

    // Xử lý tất cả các ngoại lệ chưa được xác định
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorsResponse> handleAllExceptions() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.INTERNAL_SERVER_ERROR.value(), "Đã có lỗi xảy ra(chưa xác định)", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}


/* ===== identity_service/IdentityServiceApplication.java ===== */
package com.hau.identity_service;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableScheduling
@EnableFeignClients
public class IdentityServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(IdentityServiceApplication.class, args);
    }
}


/* ===== identity_service/mapper/PermissionMapper.java ===== */
package com.hau.identity_service.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.NullValuePropertyMappingStrategy;

import com.hau.identity_service.dto.request.PermissionCreationRequest;
import com.hau.identity_service.dto.response.PermissionResponse;
import com.hau.identity_service.entity.Permission;

@Mapper(componentModel = "spring", nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface PermissionMapper {
    Permission toPermission(PermissionCreationRequest permissionCreationRequest);

    PermissionResponse toPermissionResponse(Permission permission);
}


/* ===== identity_service/mapper/RoleMapper.java ===== */
package com.hau.identity_service.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.NullValuePropertyMappingStrategy;

import com.hau.identity_service.dto.request.RoleCreationRequest;
import com.hau.identity_service.dto.response.RoleResponse;
import com.hau.identity_service.entity.Role;

@Mapper(componentModel = "spring", nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface RoleMapper {
    @Mapping(target = "permissions", ignore = true)
    Role toRole(RoleCreationRequest roleCreationRequest);

    RoleResponse toRoleResponse(Role role);
}


/* ===== identity_service/mapper/UserMapper.java ===== */
package com.hau.identity_service.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;

import com.hau.identity_service.dto.request.UserCreateRequest;
import com.hau.identity_service.dto.request.UserUpdateInfoRequest;
import com.hau.identity_service.dto.request.UserUpdateRequest;
import com.hau.identity_service.dto.response.UserResponse;
import com.hau.identity_service.entity.User;

@Mapper(componentModel = "spring", nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public interface UserMapper {
    @Mapping(target = "roles", ignore = true)
    User toUser(UserCreateRequest userCreateRequest);

    @Mapping(target = "roles", ignore = true)
    void toUserUpdateRequest(@MappingTarget User user, UserUpdateRequest userUpdateRequest);

    UserResponse toUserResponse(User user);
}


/* ===== identity_service/repository/CartServiceClient.java ===== */
package com.hau.identity_service.repository;

import com.hau.identity_service.config.AuthenticationRequestInterceptor;
import com.hau.identity_service.dto.request.CartCreateRequest;
import com.hau.identity_service.dto.response.CartResponse;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

@FeignClient(name = "cart-service", url = "${app.cart-service.url}",
        configuration = {AuthenticationRequestInterceptor.class})
public interface CartServiceClient {
    @PostMapping(value = "/cart/internal/users", produces = MediaType.APPLICATION_JSON_VALUE)
    CartResponse createCart(@RequestBody CartCreateRequest cartCreateRequest);
}


/* ===== identity_service/repository/FileServiceClient.java ===== */
package com.hau.identity_service.repository;

import com.hau.identity_service.config.AuthenticationRequestInterceptor;
import com.hau.identity_service.config.FeignMultipartSupportConfig;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.FileResponse;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.multipart.MultipartFile;

@FeignClient(name = "file-service", url = "${app.file-service.url}",
        configuration = {AuthenticationRequestInterceptor.class, FeignMultipartSupportConfig.class})
public interface FileServiceClient {
    @PostMapping(value = "/file/media", consumes = MediaType.MULTIPART_FORM_DATA_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    ApiResponse<FileResponse> uploadFile(@RequestPart("file") MultipartFile file);

    @DeleteMapping
    ApiResponse<FileResponse> deleteFile(@RequestPart("fileUrl") String fileUrl);
}


/* ===== identity_service/repository/InvalidatedTokenRepository.java ===== */
package com.hau.identity_service.repository;

import java.util.Date;
import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;

import com.hau.identity_service.entity.InvalidatedToken;

public interface InvalidatedTokenRepository extends JpaRepository<InvalidatedToken, String> {
    List<InvalidatedToken> findByExpiryDateLessThanEqual(Date expiryDate);
}


/* ===== identity_service/repository/PermissionRepository.java ===== */
package com.hau.identity_service.repository;

import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import com.hau.identity_service.entity.Permission;

@Repository
public interface PermissionRepository extends JpaRepository<Permission, String>, JpaSpecificationExecutor<Permission> {
    Optional<Permission> findByName(String name);
}


/* ===== identity_service/repository/RoleRepository.java ===== */
package com.hau.identity_service.repository;

import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import com.hau.identity_service.entity.Role;

@Repository
public interface RoleRepository extends JpaRepository<Role, String>, JpaSpecificationExecutor<Role> {
    Optional<Role> findByName(String name);
}


/* ===== identity_service/repository/UserRepository.java ===== */
package com.hau.identity_service.repository;

import java.util.Optional;

import org.springframework.data.domain.Page;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import com.hau.identity_service.entity.User;

@Repository
public interface UserRepository extends JpaRepository<User, Long>, JpaSpecificationExecutor<User> {
    Optional<User> findByUsername(String username);
}


/* ===== identity_service/service/AuthenticationService.java ===== */
package com.hau.identity_service.service;

import java.text.ParseException;
import java.time.LocalDateTime;
import java.util.Date;

import org.springframework.http.HttpStatus;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import com.hau.identity_service.dto.request.AuthenticationRequest;
import com.hau.identity_service.dto.request.IntrospectRequest;
import com.hau.identity_service.dto.request.LogoutRequest;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.AuthenticationResponse;
import com.hau.identity_service.dto.response.IntrospectResponse;
import com.hau.identity_service.entity.InvalidatedToken;
import com.hau.identity_service.entity.User;
import com.hau.identity_service.exception.AppException;
import com.hau.identity_service.repository.InvalidatedTokenRepository;
import com.hau.identity_service.repository.UserRepository;
import com.nimbusds.jose.*;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@RequiredArgsConstructor
@Service
@Slf4j
public class AuthenticationService {
    private final UserRepository userRepository;
    private final InvalidatedTokenRepository invalidatedTokenRepository;
    private final PasswordEncoder passwordEncoder;
    private final TokenService tokenService;


    public ApiResponse<AuthenticationResponse> authenticate(AuthenticationRequest authenticationRequest) {
        User user = userRepository
                .findByUsername(authenticationRequest.getUsername())
                .orElse(null);

        if (user == null || !passwordEncoder.matches(authenticationRequest.getPassword(), user.getPassword())) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Tên đăng nhập hoặc mật khẩu không chính xác", null);
        }

        String token;
        try {
            token = tokenService.generateToken(user);
        } catch (JOSEException e) {
            throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi tạo token", e);
        }

        return ApiResponse.<AuthenticationResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Đăng nhập thành công")
                .result(AuthenticationResponse.builder()
                        .authenticated(true)
                        .token(token)
                        .build())
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<Void> logout(LogoutRequest logoutRequest) throws ParseException {
        var signToken = tokenService.verifyToken(logoutRequest.getToken(), true);
        String jit = signToken.getJWTClaimsSet().getJWTID();
        Date expiryTime = signToken.getJWTClaimsSet().getExpirationTime();

        InvalidatedToken invalidatedToken =
                InvalidatedToken.builder().id(jit).expiryDate(expiryTime).build();
        invalidatedTokenRepository.save(invalidatedToken);
        return ApiResponse.<Void>builder()
                .status(HttpStatus.OK.value())
                .message("Đăng xuất thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<IntrospectResponse> introspect(IntrospectRequest introspectRequest) {
        String token = introspectRequest.getToken();

        if (token == null || token.isEmpty()) {
            return buildErrorResponse("Token không được cung cấp");
        }

        try {
            // Sử dụng TokenService thay vì logic tại chỗ
            IntrospectResponse result = tokenService.validateToken(token);

            if (result.isValid()) {
                return ApiResponse.<IntrospectResponse>builder()
                        .status(HttpStatus.OK.value())
                        .message("Token hợp lệ")
                        .result(result)
                        .timestamp(LocalDateTime.now())
                        .build();
            } else {
                return buildErrorResponse("Token không hợp lệ");
            }
        } catch (Exception e) {
            return buildErrorResponse(e.getMessage());
        }
    }

    private ApiResponse<IntrospectResponse> buildErrorResponse(String message) {
        return ApiResponse.<IntrospectResponse>builder()
                .status(HttpStatus.BAD_REQUEST.value())
                .message(message)
                .result(IntrospectResponse.builder().valid(false).build())
                .timestamp(LocalDateTime.now())
                .build();
    }
}


/* ===== identity_service/service/ForgotPasswordService.java ===== */
package com.hau.identity_service.service;

import java.text.ParseException;
import java.time.Duration;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.Date;
import java.util.Map;
import java.util.Random;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

import com.hau.event.dto.NotificationEvent;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import com.hau.identity_service.dto.request.ForgotPasswordRequest;
import com.hau.identity_service.dto.request.ResetPasswordWithTokenRequest;
import com.hau.identity_service.dto.request.VerifyOtpRequest;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.VerifyOtpResponse;
import com.hau.identity_service.entity.User;
import com.hau.identity_service.exception.AppException;
import com.hau.identity_service.repository.UserRepository;
import com.nimbusds.jose.*;
import com.nimbusds.jose.crypto.MACSigner;
import com.nimbusds.jose.crypto.MACVerifier;
import com.nimbusds.jwt.JWTClaimsSet;
import com.nimbusds.jwt.SignedJWT;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class ForgotPasswordService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final KafkaTemplate<String, Object> kafkaTemplate;

    @Value("${jwt.signerKey}")
    private String signerKey;

    @Value("${jwt.issuer}")
    private String issuer;

    @Value("${jwt.passwordResetTokenExpiryMinutes}")
    private long passwordResetTokenExpiryMinutes;

    @Value("${jwt.otpExpiryMinutes}")
    private long otpExpiryMinutes;

    @Value("${jwt.otpRequestCooldownMinutes}")
    private long otpRequestCooldownMinutes;

    private static final Random random = new Random();
    private static final String PURPOSE_CLAIM = "purpose";
    private static final String PURPOSE_VALUE = "PASSWORD_RESET";

    private final Map<String, String> otpCache = new ConcurrentHashMap<>();
    private final Map<String, LocalDateTime> otpExpiryCache = new ConcurrentHashMap<>();

    private final Map<String, LocalDateTime> otpRequestTimestamps = new ConcurrentHashMap<>();

    private final Map<String, LocalDateTime> usedResetTokens = new ConcurrentHashMap<>();

    public ApiResponse<String> sendOtp(ForgotPasswordRequest forgotPasswordRequest) {
        String username = forgotPasswordRequest.getUsername();

        // --- Rate Limiting Check ---
        LocalDateTime lastRequestTime = otpRequestTimestamps.get(username);
        LocalDateTime now = LocalDateTime.now();
        if (lastRequestTime != null) {
            Duration timeSinceLastRequest = Duration.between(lastRequestTime, now);
            if (timeSinceLastRequest.toMinutes() < otpRequestCooldownMinutes) {
                long waitMinutes = otpRequestCooldownMinutes - timeSinceLastRequest.toMinutes();
                log.warn("Rate limit hit for OTP request by user: {}. Wait {} more minute(s).", username, waitMinutes);
                return ApiResponse.<String>builder()
                        .status(HttpStatus.TOO_MANY_REQUESTS.value())
                        .message("Bạn vừa yêu cầu OTP gần đây. Vui lòng đợi " + waitMinutes
                                + " phút nữa trước khi thử lại.")
                        .result(null)
                        .timestamp(now)
                        .build();
            }
        }
        // --- End Rate Limiting Check ---

        User user = userRepository
                .findByUsername(username)
                .orElseThrow(() -> new AppException(
                        HttpStatus.NOT_FOUND, "Không tìm thấy người dùng với username: " + username, null));

        String otp = generateOtp();
        otpCache.put(username, otp);
        otpExpiryCache.put(username, now.plusMinutes(otpExpiryMinutes));

        log.info("Generated OTP for user {}. Triggering async email.", username);

        NotificationEvent notificationEvent = NotificationEvent.builder()
                .channel("EMAIL")
                .recipient(user.getEmail())
                .templateCode("otp-email-template")
                .params(Map.of(
                        "username", username,
                        "otp", otp,
                        "expiryMinutes", otpExpiryMinutes
                ))
                .build();
        kafkaTemplate.send("forgot-password-topic", notificationEvent);

        // Update the timestamp *after* successfully processing the request
        otpRequestTimestamps.put(username, now);

        return ApiResponse.<String>builder()
                .status(HttpStatus.OK.value())
                .message("Yêu cầu gửi OTP đã được xử lý. Vui lòng kiểm tra email của bạn.")
                .result(null)
                .timestamp(now)
                .build();
    }

    public ApiResponse<VerifyOtpResponse> verifyOtp(VerifyOtpRequest verifyOtpRequest) {
        // Extract username from the request body DTO
        String username = verifyOtpRequest.getUsername();
        int otp = verifyOtpRequest.getOtp(); // Get OTP from request

        String cachedOtp = otpCache.get(username);
        LocalDateTime expiryTime = otpExpiryCache.get(username);
        LocalDateTime now = LocalDateTime.now();

        // --- Logic using the extracted username ---
        if (cachedOtp == null) {
            log.warn("Verify OTP attempt for user '{}' failed: No OTP found in cache.", username);
            return buildVerifyOtpErrorResponse("OTP không hợp lệ hoặc chưa được yêu cầu. Vui lòng thử lại.");
        }

        if (expiryTime != null && now.isAfter(expiryTime)) {
            log.warn("Verify OTP attempt for user '{}' failed: OTP expired.", username);
            otpCache.remove(username);
            otpExpiryCache.remove(username);
            return buildVerifyOtpErrorResponse("OTP đã hết hạn. Vui lòng yêu cầu OTP mới.");
        }

        if (!cachedOtp.equals(String.valueOf(otp))) {
            log.warn("Verify OTP attempt for user '{}' failed: Incorrect OTP.", username);
            // Consider adding rate limiting for failed attempts here
            return buildVerifyOtpErrorResponse("OTP không chính xác. Vui lòng thử lại.");
        }
        // --- End Logic ---

        // OTP is correct, remove it from cache
        otpCache.remove(username);
        otpExpiryCache.remove(username);
        log.info("OTP successfully verified for user '{}'.", username);

        // Generate Password Reset JWT
        String passwordResetToken;
        try {
            passwordResetToken = generatePasswordResetToken(username); // Pass username to token generation
            log.info("Generated password reset JWT for user {}", username);
        } catch (JOSEException e) {
            log.error("Error generating password reset JWT for user {}: {}", username, e.getMessage());
            throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi tạo mã xác nhận đặt lại mật khẩu", e);
        }

        return ApiResponse.<VerifyOtpResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Xác thực OTP thành công. Mã xác nhận đặt lại mật khẩu đã được tạo.")
                .result(VerifyOtpResponse.builder()
                        .verificationToken(passwordResetToken)
                        .build())
                .timestamp(now)
                .build();
    }

    public ApiResponse<String> resetPassword(ResetPasswordWithTokenRequest resetPasswordWithTokenRequest) {
        String verificationToken = resetPasswordWithTokenRequest.getVerificationToken();
        String username;
        String jti; // JWT ID
        Date tokenExpiry;

        JWTClaimsSet claimsSet;
        try {
            claimsSet = validatePasswordResetToken(verificationToken); // Validation now includes blacklist check
            username = claimsSet.getSubject();
            jti = claimsSet.getJWTID(); // Get JTI
            tokenExpiry = claimsSet.getExpirationTime(); // Get expiry for blacklist

            if (username == null || username.trim().isEmpty() || jti == null || tokenExpiry == null) {
                log.error("Validated password reset token is missing critical claims (sub, jti, or exp).");
                throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi xử lý mã xác nhận.", null);
            }
        } catch (AppException e) {
            return ApiResponse.<String>builder()
                    .status(e.getHttpStatus().value())
                    .message(e.getMessage())
                    .result(null)
                    .timestamp(LocalDateTime.now())
                    .build();
        } catch (Exception e) {
            log.error("Unexpected error processing password reset token: {}", e.getMessage(), e);
            return ApiResponse.<String>builder()
                    .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
                    .message("Lỗi không xác định khi xử lý mã đặt lại mật khẩu.")
                    .result(null)
                    .timestamp(LocalDateTime.now())
                    .build();
        }

        User user = userRepository.findByUsername(username).orElseThrow(() -> {
            log.error("User '{}' not found after successful token validation (JTI: {}).", username, jti);
            return new AppException(
                    HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi không mong đợi: Không tìm thấy người dùng.", null);
        });

        user.setPassword(passwordEncoder.encode(resetPasswordWithTokenRequest.getNewPassword()));
        userRepository.save(user);

        // --- Add token JTI to blacklist after successful password reset ---
        // Store with original expiry time to allow potential cleanup later
        usedResetTokens.put(
                jti,
                tokenExpiry.toInstant().atZone(java.time.ZoneId.systemDefault()).toLocalDateTime());
        log.info("Password successfully reset for user {}. Token JTI {} blacklisted.", username, jti);
        // Note: In a production/scaled environment, consider a more robust blacklist (e.g., Redis with TTL)
        // and a cleanup mechanism for the in-memory map if used long-term.
        // --- End blacklist update ---

        return ApiResponse.<String>builder()
                .status(HttpStatus.OK.value())
                .message("Mật khẩu đã được đặt lại thành công.")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    // --- Helper Methods ---

    private String generatePasswordResetToken(String username) throws JOSEException {
        JWSHeader jwsHeader = new JWSHeader(JWSAlgorithm.HS512);
        JWTClaimsSet jwtClaimsSet = new JWTClaimsSet.Builder()
                .subject(username)
                .issuer(issuer)
                .issueTime(new Date())
                .expirationTime(new Date(Instant.now()
                        .plus(passwordResetTokenExpiryMinutes, ChronoUnit.MINUTES)
                        .toEpochMilli()))
                .claim(PURPOSE_CLAIM, PURPOSE_VALUE)
                .jwtID(UUID.randomUUID().toString()) // Ensure unique JTI is generated
                .build();

        Payload payload = new Payload(jwtClaimsSet.toJSONObject());
        JWSObject jwsObject = new JWSObject(jwsHeader, payload);
        jwsObject.sign(new MACSigner(signerKey.getBytes()));
        return jwsObject.serialize();
    }

    private JWTClaimsSet validatePasswordResetToken(String token) throws ParseException, JOSEException, AppException {
        SignedJWT signedJWT = SignedJWT.parse(token);
        JWSVerifier verifier = new MACVerifier(signerKey.getBytes());

        boolean signatureValid = signedJWT.verify(verifier);
        if (!signatureValid) {
            log.warn("Invalid password reset token signature received.");
            throw new AppException(HttpStatus.BAD_REQUEST, "Mã xác nhận không hợp lệ (chữ ký sai).", null);
        }

        JWTClaimsSet claimsSet = signedJWT.getJWTClaimsSet();
        String jti = claimsSet.getJWTID();
        String tokenUsername = claimsSet.getSubject(); // Get username for logging context

        // --- Check Blacklist (Single-Use) ---
        if (jti != null && usedResetTokens.containsKey(jti)) {
            log.warn("Attempt to reuse already used password reset token. User: {}, JTI: {}", tokenUsername, jti);
            // Consider 409 Conflict, but 400 is also common.
            throw new AppException(
                    HttpStatus.BAD_REQUEST,
                    "Mã xác nhận đã được sử dụng. Vui lòng thực hiện lại quy trình quên mật khẩu.",
                    null);
        }
        // --- End Blacklist Check ---

        Date expirationTime = claimsSet.getExpirationTime();
        if (expirationTime == null || expirationTime.before(new Date())) {
            log.info("Expired password reset token used (User: {}, JTI: {}).", tokenUsername, jti);
            throw new AppException(HttpStatus.BAD_REQUEST, "Mã xác nhận đã hết hạn.", null);
        }

        String tokenIssuer = claimsSet.getIssuer();
        if (tokenIssuer == null || !tokenIssuer.equals(issuer)) {
            log.warn(
                    "Invalid issuer in password reset token. User: {}, Expected: {}, Found: {}. JTI: {}",
                    tokenUsername,
                    issuer,
                    tokenIssuer,
                    jti);
            throw new AppException(HttpStatus.BAD_REQUEST, "Mã xác nhận không hợp lệ (issuer sai).", null);
        }

        String purpose = claimsSet.getStringClaim(PURPOSE_CLAIM);
        if (!PURPOSE_VALUE.equals(purpose)) {
            log.warn(
                    "Incorrect purpose claim in token. User: {}, Expected: {}, Found: {}. JTI: {}",
                    tokenUsername,
                    PURPOSE_VALUE,
                    purpose,
                    jti);
            throw new AppException(HttpStatus.BAD_REQUEST, "Mã xác nhận không hợp lệ (mục đích sai).", null);
        }

        if (tokenUsername == null || tokenUsername.trim().isEmpty()) {
            log.warn("Password reset token is missing the subject (username) claim. JTI: {}", jti);
            throw new AppException(
                    HttpStatus.BAD_REQUEST, "Mã xác nhận không hợp lệ (thiếu thông tin người dùng).", null);
        }

        Date issueTime = claimsSet.getIssueTime();
        if (issueTime != null && issueTime.after(new Date())) {
            log.warn("Password reset token used before issue time for user {}. JTI: {}", tokenUsername, jti);
            throw new AppException(HttpStatus.BAD_REQUEST, "Mã xác nhận chưa có hiệu lực.", null);
        }

        if (jti == null) {
            // Should not happen if generation includes it, but check defensively.
            log.error("Password reset token is missing the JTI claim. User: {}", tokenUsername);
            throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi xử lý mã xác nhận (thiếu JTI).", null);
        }

        log.info("Password reset token successfully validated for user {}", tokenUsername);
        return claimsSet;
    }

    private String generateOtp() {
        int otpValue = 100000 + random.nextInt(900000);
        return String.valueOf(otpValue);
    }

    private ApiResponse<VerifyOtpResponse> buildVerifyOtpErrorResponse(String message) {
        return ApiResponse.<VerifyOtpResponse>builder()
                .status(HttpStatus.BAD_REQUEST.value())
                .message(message)
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }
}


/* ===== identity_service/service/PermissionService.java ===== */
package com.hau.identity_service.service;

import java.time.LocalDateTime;
import java.util.List;

import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import com.hau.identity_service.dto.request.PermissionCreationRequest;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.PermissionResponse;
import com.hau.identity_service.entity.Permission;
import com.hau.identity_service.exception.AppException;
import com.hau.identity_service.mapper.PermissionMapper;
import com.hau.identity_service.repository.PermissionRepository;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class PermissionService {

    private final PermissionRepository permissionRepository;
    private final PermissionMapper permissionMapper;

    public ApiResponse<PermissionResponse> createPermission(PermissionCreationRequest permissionCreationRequest) {
        Permission permission = permissionMapper.toPermission(permissionCreationRequest);
        permissionRepository.save(permission);
        return ApiResponse.<PermissionResponse>builder()
                .status(HttpStatus.CREATED.value())
                .message("Tạo mới quyền thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<List<PermissionResponse>> getAllPermissions() {
        List<Permission> permissions = permissionRepository.findAll();
        List<PermissionResponse> permissionResponses =
                permissions.stream().map(permissionMapper::toPermissionResponse).toList();
        return ApiResponse.<List<PermissionResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách quyền thành công")
                .result(permissionResponses)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<PermissionResponse> deletePermission(String name) {
        Permission permission = permissionRepository
                .findByName(name)
                .orElseThrow(
                        () -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy quyền với tên: " + name, null));
        permissionRepository.delete(permission);
        return ApiResponse.<PermissionResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Xóa quyền thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }
}


/* ===== identity_service/service/RoleService.java ===== */
package com.hau.identity_service.service;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.List;

import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import com.hau.identity_service.dto.request.RoleCreationRequest;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.RoleResponse;
import com.hau.identity_service.entity.Role;
import com.hau.identity_service.exception.AppException;
import com.hau.identity_service.mapper.RoleMapper;
import com.hau.identity_service.repository.PermissionRepository;
import com.hau.identity_service.repository.RoleRepository;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@RequiredArgsConstructor
@Slf4j
public class RoleService {
    private final RoleRepository roleRepository;
    private final PermissionRepository permissionRepository;
    private final RoleMapper roleMapper;

    public ApiResponse<RoleResponse> createRole(RoleCreationRequest request) {
        var role = roleMapper.toRole(request);
        var permissionIds = request.getPermissions();
        var permissions = permissionRepository.findAllById(permissionIds);
        if (CollectionUtils.isEmpty(permissions)) {
            return ApiResponse.<RoleResponse>builder()
                    .status(HttpStatus.BAD_REQUEST.value())
                    .message("Không tìm thấy permission nào")
                    .result(null)
                    .timestamp(LocalDateTime.now())
                    .build();
        }
        role.setPermissions(new HashSet<>(permissions));
        roleRepository.save(role);
        return ApiResponse.<RoleResponse>builder()
                .status(HttpStatus.CREATED.value())
                .message("Tạo role thành công")
                .result(roleMapper.toRoleResponse(role))
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<List<RoleResponse>> getAllRoles() {
        List<Role> roles = roleRepository.findAll();
        List<RoleResponse> roleResponses =
                roles.stream().map(roleMapper::toRoleResponse).toList();
        return ApiResponse.<List<RoleResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách role thành công")
                .result(roleResponses)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<RoleResponse> deleteRole(String name) {
        Role role = roleRepository
                .findByName(name)
                .orElseThrow(
                        () -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy role với tên: " + name, null));
        roleRepository.delete(role);
        return ApiResponse.<RoleResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Xóa role thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }
}


/* ===== identity_service/service/TokenService.java ===== */
package com.hau.identity_service.service;

import java.text.ParseException;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.temporal.ChronoUnit;
import java.util.Date;
import java.util.List;
import java.util.StringJoiner;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import com.hau.identity_service.dto.request.RefreshTokenRequest;
import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.AuthenticationResponse;
import com.hau.identity_service.dto.response.IntrospectResponse;
import com.hau.identity_service.entity.InvalidatedToken;
import com.hau.identity_service.entity.User;
import com.hau.identity_service.exception.AppException;
import com.hau.identity_service.repository.InvalidatedTokenRepository;
import com.hau.identity_service.repository.UserRepository;
import com.nimbusds.jose.*;
import com.nimbusds.jose.crypto.MACSigner;
import com.nimbusds.jose.crypto.MACVerifier;
import com.nimbusds.jwt.JWTClaimsSet;
import com.nimbusds.jwt.SignedJWT;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Service
@Slf4j
@RequiredArgsConstructor
public class TokenService {

    @Value("${jwt.signerKey}")
    private String signerKey;

    @Value("${jwt.issuer}")
    private String issuer;

    @Value("${jwt.expirationMinutes}")
    private Long expiration;

    @Value("${jwt.expirationRefreshMinutes}")
    private Long expirationRefresh;

    private final InvalidatedTokenRepository invalidatedTokenRepository;
    private final UserRepository userRepository;

    private JWTClaimsSet validateTokenClaims(String token, boolean isRefresh) throws AppException {
        try {
            JWSVerifier verifier = new MACVerifier(signerKey.getBytes());
            SignedJWT signedJWT = SignedJWT.parse(token);
            JWTClaimsSet claimsSet = signedJWT.getJWTClaimsSet();

            if (!signedJWT.verify(verifier)) {
                throw new AppException(HttpStatus.BAD_REQUEST, "Chữ ký token không hợp lệ", null);
            }

            Date expirationTime = (isRefresh)
                    ? new Date(claimsSet
                            .getIssueTime()
                            .toInstant()
                            .plus(expirationRefresh, ChronoUnit.MINUTES)
                            .toEpochMilli())
                    : claimsSet.getExpirationTime();

            if (expirationTime == null || expirationTime.before(new Date())) {
                throw new AppException(HttpStatus.BAD_REQUEST, "Token đã hết hạn", null);
            }

            if (claimsSet.getIssuer() == null || !claimsSet.getIssuer().equals(issuer)) {
                throw new AppException(HttpStatus.BAD_REQUEST, "Token issuer không hợp lệ", null);
            }

            if (claimsSet.getIssueTime() != null && claimsSet.getIssueTime().after(new Date())) {
                throw new AppException(HttpStatus.BAD_REQUEST, "Token chưa có hiệu lực", null);
            }

            if (invalidatedTokenRepository.existsById(claimsSet.getJWTID())) {
                throw new AppException(HttpStatus.BAD_REQUEST, "Token đã hết hiệu lực", null);
            }

            return claimsSet;

        } catch (ParseException | JOSEException e) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Token không hợp lệ", null);
        }
    }

    public SignedJWT verifyToken(String token, boolean isRefresh) throws AppException {
        try {
            validateTokenClaims(token, isRefresh);
            return SignedJWT.parse(token);
        } catch (ParseException e) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Token không hợp lệ", null);
        }
    }

    public IntrospectResponse validateToken(String token) {
        if (token == null || token.isEmpty()) {
            return IntrospectResponse.builder().valid(false).build(); // Use the builder directly
        }
        try {
            JWTClaimsSet claimsSet = validateTokenClaims(token, false);
            return IntrospectResponse.builder()
                    .valid(true)
                    .username(claimsSet.getSubject())
                    .build();
        } catch (AppException e) {
            return IntrospectResponse.builder().valid(false).build(); // Consistent error handling
        }
    }

    public String generateToken(User user) throws JOSEException {
        JWSHeader jwsHeader = new JWSHeader(JWSAlgorithm.HS512);
        JWTClaimsSet jwtClaimsSet = new JWTClaimsSet.Builder()
                .issuer(issuer)
                .subject(user.getId().toString())
                .claim("username", user.getUsername())
                .issueTime(new Date())
                .expirationTime(new Date(
                        Instant.now().plus(expiration, ChronoUnit.MINUTES).toEpochMilli()))
                .claim("scope", buildScope(user))
                .jwtID(UUID.randomUUID().toString())
                .build();

        Payload payload = new Payload(jwtClaimsSet.toJSONObject());
        JWSObject jwsObject = new JWSObject(jwsHeader, payload);
        jwsObject.sign(new MACSigner(signerKey.getBytes()));
        return jwsObject.serialize();
    }

    public ApiResponse<AuthenticationResponse> refreshToken(RefreshTokenRequest refreshTokenRequest)
            throws JOSEException, ParseException {
        SignedJWT signedJWT = verifyToken(refreshTokenRequest.getToken(), true);

        String jwtId = signedJWT.getJWTClaimsSet().getJWTID();
        Date expiryTime = signedJWT.getJWTClaimsSet().getExpirationTime();

        invalidatedTokenRepository.save(
                InvalidatedToken.builder().id(jwtId).expiryDate(expiryTime).build());

        String username = signedJWT.getJWTClaimsSet().getSubject();
        log.info("Refresh token for user: {}", username);
        User user = userRepository
                .findByUsername(username)
                .orElseThrow(() -> new AppException(HttpStatus.BAD_REQUEST, "Người dùng không tồn tại", null));

        String token = generateToken(user);
        log.info("Refresh token: {}", token);

        return ApiResponse.<AuthenticationResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Làm mới token thành công")
                .result(AuthenticationResponse.builder()
                        .authenticated(true)
                        .token(token)
                        .build())
                .timestamp(LocalDateTime.now())
                .build();
    }

    private String buildScope(User user) {
        StringJoiner stringJoiner = new StringJoiner(" ");
        if (!CollectionUtils.isEmpty(user.getRoles())) {
            user.getRoles().forEach(role -> {
                stringJoiner.add("ROLE_" + role.getName());
                if (!CollectionUtils.isEmpty(role.getPermissions())) {
                    role.getPermissions().forEach(permission -> stringJoiner.add(permission.getName()));
                }
            });
        }
        return stringJoiner.toString();
    }

    @Scheduled(fixedRate = 1440, timeUnit = TimeUnit.MINUTES)
    public void cleanupExpiredTokens() {
        LocalDateTime now = LocalDateTime.now();
        Date date = Date.from(now.atZone(ZoneId.systemDefault()).toInstant());
        List<InvalidatedToken> expiredTokens = invalidatedTokenRepository.findByExpiryDateLessThanEqual(date);
        invalidatedTokenRepository.deleteAll(expiredTokens);
        log.info("Cleaned up {} expired tokens.", expiredTokens.size()); // Use SLF4J
    }
}


/* ===== identity_service/service/UserService.java ===== */
package com.hau.identity_service.service;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import com.hau.event.dto.UserCreateEvent;
import com.hau.identity_service.dto.request.*;
import com.hau.identity_service.dto.response.PageResponse;
import com.hau.identity_service.repository.CartServiceClient;
import com.hau.identity_service.repository.FileServiceClient;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import com.hau.identity_service.dto.response.ApiResponse;
import com.hau.identity_service.dto.response.UserResponse;
import com.hau.identity_service.entity.User;
import com.hau.identity_service.exception.AppException;
import com.hau.identity_service.mapper.UserMapper;
import com.hau.identity_service.repository.RoleRepository;
import com.hau.identity_service.repository.UserRepository;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.multipart.MultipartFile;

@RequiredArgsConstructor
@Service
@Slf4j
public class UserService {
    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final UserMapper userMapper;
    private final PasswordEncoder passwordEncoder;
    private final CartServiceClient cartServiceClient;
    private final FileServiceClient fileServiceClient;
    private final KafkaTemplate<String, Object> kafkaTemplate;

    @Value("${app.file.download-prefix}")
    private String fileDownloadPrefix;

    @Value("${app.file.default-image}")
    private String defaultImage;

    public ApiResponse<UserResponse> createUser(UserCreateRequest userCreateRequest) {
        User user = userMapper.toUser(userCreateRequest);
        var roles = roleRepository.findAllById(Set.of("USER"));
        user.setRoles(new HashSet<>(roles));
        user.setPassword(passwordEncoder.encode(userCreateRequest.getPassword()));
        user.setProfileImage(defaultImage);
        try {
            userRepository.save(user);
            UserCreateEvent userCreateEvent = UserCreateEvent.builder()
                    .id(user.getId())
                    .email(user.getEmail())
                    .username(user.getUsername())
                    .build();
            kafkaTemplate.send("user-created-topic", userCreateEvent);
            CartCreateRequest cartRequest = CartCreateRequest.builder()
                    .userId(user.getId())
                    .id(user.getId())
                    .build();
            cartServiceClient.createCart(cartRequest);
            return ApiResponse.<UserResponse>builder()
                    .status(HttpStatus.CREATED.value())
                    .message("Tạo mới user thành công")
                    .result(null)
                    .timestamp(LocalDateTime.now())
                    .build();
        } catch (DataIntegrityViolationException ex) {
            throw new AppException(HttpStatus.BAD_REQUEST, "username đã tồn tại", null);
        } catch (Exception feignException) {
            log.error("Lỗi khi tạo giỏ hàng cho user {}: {}", user.getUsername(), feignException.getMessage(), feignException);
        }
        return null;
    }

    public ApiResponse<UserResponse> updateUserProfileImage(MultipartFile profileImage) {
        if (profileImage == null || profileImage.isEmpty()) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Vui lòng chọn ảnh để tải lên", null);
        }
        var authentication = SecurityContextHolder.getContext().getAuthentication();
        User user = findUserById(Long.valueOf(authentication.getName()));
        try {
            var fileResponse = fileServiceClient.uploadFile(profileImage);
            if (fileResponse != null && fileResponse.getResult() != null) {
                user.setProfileImage(fileResponse.getResult().getUrl());
            } else {
                throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Không nhận được thông tin từ file-service", null);
            }

            userRepository.save(user);
            return ApiResponse.<UserResponse>builder()
                    .status(HttpStatus.OK.value())
                    .message("Cập nhật ảnh đại diện thành công")
                    .result(null)
                    .timestamp(LocalDateTime.now())
                    .build();

        } catch (Exception e) {
            throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi khi tải ảnh profile lên dịch vụ file", e);
        }
    }


    public ApiResponse<PageResponse<UserResponse>> getAllUsers(int page, int size) {
        Sort sort = Sort.by("createdAt").descending();

        Pageable pageable = PageRequest.of(page - 1, size, sort);
        Page<User> userPage = userRepository.findAll(pageable);

        List<UserResponse> userResponseList = userPage.map(userMapper::toUserResponse).toList();
        userResponseList.forEach(userResponse -> userResponse.setProfileImage(fileDownloadPrefix + userResponse.getProfileImage()));
        return ApiResponse.<PageResponse<UserResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách user thành công")
                .result(PageResponse.<UserResponse>builder()
                        .currentPage(page)
                        .totalPages(userPage.getTotalPages())
                        .totalElements(userPage.getTotalElements())
                        .pageSize(userPage.getSize())
                        .data(userResponseList)
                        .build())
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<UserResponse> myInfo() {
        var context = SecurityContextHolder.getContext();
        String id = context.getAuthentication().getName();

        User user = findUserById(Long.valueOf(id));
        UserResponse userResponse = userMapper.toUserResponse(user);
        userResponse.setProfileImage(fileDownloadPrefix + user.getProfileImage());
        return ApiResponse.<UserResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy thông tin user thành công")
                .result(userResponse)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<UserResponse> getUserById(Long id) {
        User user = findUserById(id);
        UserResponse userResponse = userMapper.toUserResponse(user);
        userResponse.setProfileImage(fileDownloadPrefix + user.getProfileImage());
        return ApiResponse.<UserResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy thông tin user thành công")
                .result(userResponse)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<UserResponse> updateUser(Long id, UserUpdateRequest userUpdateRequest) {
        User user = findUserById(id);
        userMapper.toUserUpdateRequest(user, userUpdateRequest);
        var roles = roleRepository.findAllById(userUpdateRequest.getRoles());
        user.setRoles(new HashSet<>(roles));
        user.setPassword(passwordEncoder.encode(userUpdateRequest.getPassword()));

        userRepository.save(user);
        return ApiResponse.<UserResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Cập nhật thông tin user thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<UserResponse> updateUserInfo(UserUpdateInfoRequest userUpdateInfoRequest) {
        var authentication = SecurityContextHolder.getContext().getAuthentication();
        User user = findUserById(Long.valueOf(authentication.getName()));
        user.setEmail(userUpdateInfoRequest.getEmail());
        userRepository.save(user);
        return ApiResponse.<UserResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Cập nhật thông tin user thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<UserResponse> changePassword(Long id, ChangePasswordRequest changePasswordRequest) {
        User user = findUserById(id);
        if (!passwordEncoder.matches(changePasswordRequest.getOldPassword(), user.getPassword())) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Mật khẩu cũ không đúng", null);
        }

        user.setPassword(passwordEncoder.encode(changePasswordRequest.getNewPassword()));
        userRepository.save(user);
        return ApiResponse.<UserResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Đổi mật khẩu thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<UserResponse> deleteUser(Long id) {
        User user = findUserById(id);
        userRepository.delete(user);
        return ApiResponse.<UserResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Xóa user thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public User findUserById(Long id) {
        return userRepository
                .findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy user có id: " + id, null));
    }

    public boolean isOwnerOfUser(Long requestedUserId, Authentication authentication) {
        if (authentication == null || !authentication.isAuthenticated()) {
            return false;
        }
        String authenticatedUserId = authentication.getName();
        try {
            User requestedUser = findUserById(requestedUserId);
            return requestedUser.getId().toString().equals(authenticatedUserId);
        } catch (AppException e) {
            log.warn("Không tìm thấy người dùng với ID: {}", requestedUserId);
            return false;
        }
    }
}


