/* ===== java/com/hau/event/dto/CategoryEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;


@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CategoryEvent {
    private String type;
    private Long categoryId;
    private Object data;

    // Enum hoặc Constant cho các loại sự kiện
    public static String TYPE_CREATED = "CATEGORY_CREATED";
    public static String TYPE_UPDATED = "CATEGORY_UPDATED";
    public static String TYPE_DELETED = "CATEGORY_DELETED";
}


/* ===== java/com/hau/event/dto/NotificationEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Map;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class NotificationEvent {
    private String channel;
    private String recipient;
    private String templateCode;
    private Map<String, Object> params;
}


/* ===== java/com/hau/event/dto/ProductEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductEvent {
    private Long id;
    private Integer discount;
    private Integer price;
    private Integer quantity;
    private String title;
}


/* ===== java/com/hau/event/dto/UserCreateEvent.java ===== */
package com.hau.event.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserCreateEvent {
    private String username;
    private Integer id;
}


/* ===== java/com/hau/product_service/config/AuthenticationRequestInterceptor.java ===== */
package com.hau.product_service.config;

import feign.RequestInterceptor;
import feign.RequestTemplate;
import lombok.extern.slf4j.Slf4j;
import org.springframework.util.StringUtils;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

@Slf4j
public class AuthenticationRequestInterceptor implements RequestInterceptor {
    @Override
    public void apply(RequestTemplate requestTemplate) {
        ServletRequestAttributes servletRequestAttributes =
                (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();

        assert servletRequestAttributes != null;
        var authHeader = servletRequestAttributes.getRequest().getHeader("Authorization");
        log.info("Auth header: {}", authHeader);
        if (StringUtils.hasText(authHeader) && authHeader.startsWith("Bearer ")) {
            requestTemplate.header("Authorization", authHeader);
        } else {
            log.warn("No Authorization header found in the request");
        }
    }
}


/* ===== java/com/hau/product_service/config/CustomJwtDecoder.java ===== */
package com.hau.product_service.config;

import com.nimbusds.jwt.SignedJWT;
import lombok.RequiredArgsConstructor;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.stereotype.Component;

import java.text.ParseException;

@Component
@RequiredArgsConstructor
public class CustomJwtDecoder implements JwtDecoder {
    @Override
    public Jwt decode(String token) throws JwtException {
        try {
            SignedJWT signedJWT = SignedJWT.parse(token);
            return new Jwt(token, signedJWT.getJWTClaimsSet().getIssueTime().toInstant(),
                    signedJWT.getJWTClaimsSet().getExpirationTime().toInstant(),
                    signedJWT.getHeader().toJSONObject(),
                    signedJWT.getJWTClaimsSet().getClaims()
                    );
        } catch (ParseException e) {
            throw new JwtException("Failed to parse JWT", e);
        }
    }
}


/* ===== java/com/hau/product_service/config/FeignMultipartSupportConfig.java ===== */
package com.hau.product_service.config;

import feign.codec.Encoder;
import feign.form.spring.SpringFormEncoder;
import org.springframework.boot.autoconfigure.http.HttpMessageConverters;
import org.springframework.cloud.openfeign.support.SpringEncoder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class FeignMultipartSupportConfig {
    @Bean
    public Encoder feignFormEncoder() {
        return new SpringFormEncoder(new SpringEncoder(() -> new HttpMessageConverters(new RestTemplate().getMessageConverters())));
    }
}


/* ===== java/com/hau/product_service/config/JwtAuthenticationEntryPoint.java ===== */
package com.hau.product_service.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.hau.product_service.dto.response.ApiResponse;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;

public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(
            HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)
            throws IOException {
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setCharacterEncoding(StandardCharsets.UTF_8.name());

        ApiResponse<?> apiResponse = ApiResponse.builder()
                .status(HttpStatus.UNAUTHORIZED.value())
                .message("Không có quyền truy cập")
                .timestamp(LocalDateTime.now())
                .build();

        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

        response.getWriter().write(objectMapper.writeValueAsString(apiResponse));
        response.flushBuffer();
    }
}


/* ===== java/com/hau/product_service/config/SecurityConfig.java ===== */
package com.hau.product_service.config;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableMethodSecurity
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final String[] publicPostEndpoint = {
        "/**"
    };


    private final CustomJwtDecoder customJwtDecoder;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests(request -> request.requestMatchers(HttpMethod.GET, publicPostEndpoint)
                .permitAll()
                .anyRequest()
                .authenticated());

        http.oauth2ResourceServer(oauth2 -> oauth2.jwt(jwtConfigurer -> jwtConfigurer
                        .decoder(customJwtDecoder)
                        .jwtAuthenticationConverter(jwtAuthenticationConverter()))
                .authenticationEntryPoint(new JwtAuthenticationEntryPoint()));

        http.csrf(AbstractHttpConfigurer::disable);
        return http.build();
    }

    @Bean
    JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
        jwtGrantedAuthoritiesConverter.setAuthorityPrefix("");
        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter);

        return jwtAuthenticationConverter;
    }
}

/* ===== java/com/hau/product_service/controller/CategoryController.java ===== */
package com.hau.product_service.controller;

import com.hau.product_service.dto.response.ApiResponse;
import com.hau.product_service.dto.response.CategoryResponse;
import com.hau.product_service.service.CategoryService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequiredArgsConstructor
public class CategoryController {
    private final CategoryService categoryService;

    @GetMapping("/category")
    public ResponseEntity<ApiResponse<List<CategoryResponse>>> getAllCategories() {
        ApiResponse<List<CategoryResponse>> response = categoryService.getAllCategories();
        return ResponseEntity.ok(response);
    }
}


/* ===== java/com/hau/product_service/controller/ProductController.java ===== */
package com.hau.product_service.controller;

import com.hau.event.dto.NotificationEvent;
import com.hau.product_service.dto.request.ProductFilter;
import com.hau.product_service.dto.request.ProductRequest;
import com.hau.product_service.dto.response.ApiResponse;
import com.hau.product_service.dto.response.PageResult;
import com.hau.product_service.dto.response.ProductResponse;
import com.hau.product_service.service.ProductService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;

@RestController
@RequiredArgsConstructor
public class ProductController {
    private final ProductService productService;

    @GetMapping
    public ResponseEntity<ApiResponse<PageResult<ProductResponse>> >getAllProduct(@ModelAttribute ProductFilter filter,
                                                                  @RequestParam(defaultValue = "1", required = false) Integer pageIndex,
                                                                  @RequestParam(defaultValue = "10", required = false) Integer pageSize) {
        ApiResponse<PageResult<ProductResponse>> response = productService.getAllProduct(filter, pageIndex, pageSize);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @GetMapping("/active")
    public ResponseEntity<ApiResponse<PageResult<ProductResponse>>> getAllProductByActive(@ModelAttribute ProductFilter filter,
                                                                                          @RequestParam(defaultValue = "1", required = false) Integer pageIndex,
                                                                                          @RequestParam(defaultValue = "10", required = false) Integer pageSize) {
        ApiResponse<PageResult<ProductResponse>> response = productService.getAllProductByActive(filter, pageIndex, pageSize);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @GetMapping("/top-discount")
    public ResponseEntity<ApiResponse<List<ProductResponse>>> getTopTenBestDiscountProduct() {
        ApiResponse<List<ProductResponse>> response = productService.getTopTenProductByBestDiscountPercent();
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @GetMapping("/top-rating")
    public ResponseEntity<ApiResponse<List<ProductResponse>>> getTopTenBestAverageRateProduct() {
        ApiResponse<List<ProductResponse>> response = productService.getTopTenProductByAverageRate();
        return new ResponseEntity<>(response, HttpStatus.OK);
    }


    @PostMapping
    public ResponseEntity<ApiResponse<ProductResponse>> createProduct(
            @RequestPart("product") @Valid ProductRequest request,
            @RequestPart("thumbnail") MultipartFile thumbnail,
            @RequestPart(value = "images", required = false) List<MultipartFile> images // Added: accept multiple images, make it optional
    ) {
        ApiResponse<ProductResponse> response = productService.createProduct(request, thumbnail, images);
        return new ResponseEntity<>(response, HttpStatus.CREATED);
    }

    // Modified for image/thumbnail update
    @PutMapping(value = "/{productId}")
    public ResponseEntity<ApiResponse<ProductResponse>> updateProduct(
            @PathVariable Long productId,
            @RequestPart("product") @Valid ProductRequest request,
            @RequestPart(value = "thumbnail", required = false) MultipartFile thumbnail,
            @RequestPart(value = "images", required = false) List<MultipartFile> images
    ) {
        ApiResponse<ProductResponse> response = productService.updateProduct(request, productId, thumbnail, images);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @DeleteMapping("/{productId}")
    public ResponseEntity<ApiResponse<ProductResponse>> deleteProduct(@PathVariable Long productId) {
        ApiResponse<ProductResponse> response = productService.deleteProduct(productId);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @GetMapping("/{productId}")
    public ResponseEntity<ApiResponse<ProductResponse>> getProductById(@PathVariable Long productId) {
        ApiResponse<ProductResponse> response = productService.getProductById(productId);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @KafkaListener(topics = "order-create-notification-topic")
    public void updateProductQuantity(NotificationEvent notificationEvent) {
        productService.updateProductQuantity(notificationEvent);
    }

}


/* ===== java/com/hau/product_service/controller/RateController.java ===== */
package com.hau.product_service.controller;

import com.hau.product_service.dto.request.RateRequest;
import com.hau.product_service.dto.response.ApiResponse;
import com.hau.product_service.dto.response.PageResult;
import com.hau.product_service.dto.response.RateResponse;
import com.hau.product_service.service.RateService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

@Controller
@RequiredArgsConstructor
public class RateController {
    private final RateService rateService;

    @GetMapping("/rate")
    public ResponseEntity<ApiResponse<PageResult<RateResponse>>> getAllRate(@RequestParam(required = false, defaultValue = "1")  Integer pageIndex,
                                                                            @RequestParam(required = false, defaultValue = "10") Integer pageSize) {
        ApiResponse<PageResult<RateResponse>> response = rateService.getAllRate(pageIndex, pageSize);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @GetMapping("/rate/{id}")
    public ResponseEntity<ApiResponse<RateResponse>> getRateById(@PathVariable Long id) {
        ApiResponse<RateResponse> response = rateService.getRateById(id);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @GetMapping("/rate/product/{productId}")
    public ResponseEntity<ApiResponse<PageResult<RateResponse>>> getRateByProductId(@PathVariable Long productId,
                                                                                     @RequestParam(required = false, defaultValue = "1") Integer pageIndex,
                                                                                     @RequestParam(required = false, defaultValue = "10") Integer pageSize) {
        ApiResponse<PageResult<RateResponse>> response = rateService.getRateByProductId(productId, pageIndex, pageSize);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @PostMapping("/rate")
    public ResponseEntity<ApiResponse<RateResponse>> createRate(@RequestBody @Valid RateRequest request) {
        ApiResponse<RateResponse> response = rateService.createRate(request);
        return new ResponseEntity<>(response, HttpStatus.CREATED);
    }

    @DeleteMapping("/rate/{id}")
    public ResponseEntity<ApiResponse<RateResponse>> deleteRate(@PathVariable Long id) {
        ApiResponse<RateResponse> response = rateService.removeRate(id);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }



}


/* ===== java/com/hau/product_service/converter/StringConverter.java ===== */
package com.hau.product_service.converter;

public class StringConverter {
    public static String toSlug(String str) {
        // Convert to lowercase
        str = str.toLowerCase();

        // Replace spaces with hyphens
        str = str.replaceAll(" ", "-");

        // Remove special characters
        str = str.replaceAll("[^a-z0-9-]", "");

        // Remove consecutive hyphens
        str = str.replaceAll("-+", "-");

        // Trim leading and trailing hyphens
        str = str.replaceAll("^-|-$", "");

        return str;
    }
}


/* ===== java/com/hau/product_service/dto/request/CategoryRequest.java ===== */
package com.hau.product_service.dto.request;


import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class CategoryRequest {
    @NotNull(message = "ID danh mục không được để trống")
    private Long id;
    @NotNull(message = "Tên danh mục không được để trống")
    private String name;
    @NotNull(message = "Độ ưu tiên không được để trống")
    @Min(value = 1, message = "Mức độ ưu tiên phải lớn hơn 0")
    private Integer priority;
    private Long parentId;
    private String slug;
}


/* ===== java/com/hau/product_service/dto/request/ProductFilter.java ===== */
package com.hau.product_service.dto.request;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductFilter {
    private String title;
    private String author;
    private Integer priceFrom;
    private Integer priceTo;
    private String sortBy;
    private String sortDir;
    private Long categoryId;
    private Float averageRateFrom;

    public boolean isEmpty() {
        return (title == null || title.isEmpty()) &&
                (author == null || author.isEmpty()) &&
                (priceFrom == null || priceFrom <= 0) &&
                (priceTo == null || priceTo <= 0) &&
                (sortBy == null || sortBy.isEmpty()) &&
                (sortDir == null || sortDir.isEmpty()) &&
                (categoryId == null || categoryId <= 0) &&
                (averageRateFrom == null || averageRateFrom <= 0);
    }
}


/* ===== java/com/hau/product_service/dto/request/ProductImageRequest.java ===== */
package com.hau.product_service.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@AllArgsConstructor
@NoArgsConstructor
@Data
public class ProductImageRequest {
    @NotNull
    Long productId;
    @NotBlank
    String imageUrl;
}


/* ===== java/com/hau/product_service/dto/request/ProductRequest.java ===== */
package com.hau.product_service.dto.request;

import jakarta.validation.constraints.*;
import lombok.*;
import lombok.experimental.FieldDefaults;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;

@Data
@FieldDefaults(level = AccessLevel.PRIVATE)
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProductRequest {
    @NotBlank(message = "Tên sản phẩm không được để trống")
    @NotNull
    private String title;

    @NotBlank(message = "Tác giả không được để trống")
    @NotNull
    private String author;

    @NotBlank(message = "Nhà xuất bản không được để trống")
    private String publisher;

    @NotNull(message = "Năm xuất bản không được để trống")
    private Integer publicationYear;

    @NotNull(message = "Kích thước đóng gói không được để trống")
    @Min(value = 1, message = "Kích thước đóng gói phải lớn hơn 0")
    private Integer packageSize;

    @NotNull(message = "Số trang không được để trống")
    @Min(value = 1, message = "Số trang phải lớn hơn 0")
    private Integer pageSize;

    @NotBlank(message = "Hình thức không được để trống") // ví dụ: Bìa mềm, Bìa cứng
    private String form;


    @NotNull(message = "Số lượng không được để trống")
    @Min(value = 0, message = "Số lượng phải >= 0")
    private Integer quantity;

    @NotNull(message = "giá hiện tại không được để trống")
    @Min(value = 1, message = "Giá hiện tại phải > 0")
    private Integer discount;

    @NotNull(message = "Giá cũ không được để trống")
    @Min(value = 1000, message = "Giá cũ phải > 0")
    private Integer price;

    @NotNull(message = "Độ ưu tiên không được để trống")
    @Min(value = 0, message = "Độ ưu tiên phải >= 0")
    private Integer priority;

    @NotBlank(message = "Mô tả không được để trống")
    private String description;

    Boolean active;

    private List<Long> categoryIds;
}


/* ===== java/com/hau/product_service/dto/request/RateRequest.java ===== */
package com.hau.product_service.dto.request;

import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class RateRequest {
    @NotNull(message = "Mã sản phẩm không được để trống")
    private Long productId;

    @NotNull(message = "Điểm đánh giá không được để trống")
    @Min(value = 1, message = "Điểm đánh giá phải lớn hơn hoặc bằng 1")
    @Max(value = 5, message = "Điểm đánh giá phải nhỏ hơn hoặc bằng 5")
    private int vote;

    private String comment;
}


/* ===== java/com/hau/product_service/dto/response/ApiResponse.java ===== */
package com.hau.product_service.dto.response;

import java.time.LocalDateTime;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@JsonIgnoreProperties(ignoreUnknown = true)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
    private int status;
    private String message;
    private T result;
    private LocalDateTime timestamp;
}


/* ===== java/com/hau/product_service/dto/response/CategoryResponse.java ===== */
package com.hau.product_service.dto.response;


import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class CategoryResponse {
    private Long id;
    private String name;
    private Long priority;
    private Long parentId;
    private String slug;
}


/* ===== java/com/hau/product_service/dto/response/ErrorsResponse.java ===== */
package com.hau.product_service.dto.response;

import java.time.LocalDateTime;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ErrorsResponse {
    private int status;
    private String message;
    private Object error;
    private LocalDateTime timestamp;
}


/* ===== java/com/hau/product_service/dto/response/FileResponse.java ===== */
package com.hau.product_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class FileResponse {
    private String originalFileName;
    private String url;
}


/* ===== java/com/hau/product_service/dto/response/PageResult.java ===== */
package com.hau.product_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class PageResult<T> {
    private List<T> data;
    private int pageIndex;
    private int pageSize;
    private int totalPages;
    private long totalItems;
    private boolean hasNext;
    private boolean hasPrevious;
}



/* ===== java/com/hau/product_service/dto/response/ProductImageResponse.java ===== */
package com.hau.product_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Builder
@AllArgsConstructor
@NoArgsConstructor
@Data
public class ProductImageResponse {
    private String url;
}


/* ===== java/com/hau/product_service/dto/response/ProductResponse.java ===== */
package com.hau.product_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductResponse {
    private Long id;
    private String title;
    private String author;
    private String publisher;
    private Integer publicationYear;
    private Integer packageSize;
    private Integer pageSize;
    private String form;
    private String thumbnail;
    private Integer quantity;
    private Integer discount;
    private Integer price;
    private Double discountPercent;
    private Integer priority;
    private String description;
    private Float averageRate;

    private boolean active;

    private List<String> imageUrls;
    private List<Long> categories;
}


/* ===== java/com/hau/product_service/dto/response/RateResponse.java ===== */
package com.hau.product_service.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class RateResponse {
    private Long id;
    private Long productId;
    private Integer userId;
    private Integer vote;
    private String comment;
    private String createdAt;
}


/* ===== java/com/hau/product_service/entity/Category.java ===== */
package com.hau.product_service.entity;

import jakarta.persistence.*;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.ToString;

import java.util.ArrayList;
import java.util.List;


@Table(name = "categories")
@Entity
@Data
public class Category {
    @Id
    private Long id;
    private String name;
    private String slug;
    private Long parentId;


    @ManyToMany(mappedBy = "categories", fetch = FetchType.LAZY)
    @EqualsAndHashCode.Exclude
    @ToString.Exclude
    private List<Product> products = new ArrayList<>();

}


/* ===== java/com/hau/product_service/entity/Product.java ===== */
package com.hau.product_service.entity;

import jakarta.persistence.*;
import lombok.*;
import lombok.experimental.FieldDefaults;
import org.hibernate.annotations.CreationTimestamp;

import java.util.ArrayList;
import java.util.List;

import java.time.LocalDateTime;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "products")
@FieldDefaults(level = AccessLevel.PRIVATE)
public class Product {
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Id
    Long id;
    String title;
    String author;
    String publisher;
    Integer publicationYear;
    Integer packageSize;
    Integer pageSize;
    String form;
    String thumbnail;
    Integer quantity;
    Integer discount;
    Integer price;
    Integer priority;
    String description;
    @Column(unique = true)
    String slug;
    Double discountPercent;

    @ManyToMany(fetch = FetchType.LAZY) // Use LAZY fetching
    @JoinTable(
            name = "product_category", // Name of the join table
            joinColumns = @JoinColumn(name = "product_id", referencedColumnName = "id"), // Column referring to Product's ID
            inverseJoinColumns = @JoinColumn(name = "category_id", referencedColumnName = "id") // Column referring to Category's ID
    )
    // Exclude from equals and hashCode/toString generated by Lombok @Data
    // to prevent infinite loops or StackOverflow errors in bidirectional relationships.
    @EqualsAndHashCode.Exclude
    @ToString.Exclude
    private List<Category> categories = new ArrayList<>();

    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, mappedBy = "product")
    List<ProductImage> productImage = new ArrayList<>();

    @OneToMany(mappedBy = "product", cascade = CascadeType.ALL, orphanRemoval = true)
    List<Rate> rates;

    private Float averageRate;

    boolean active;
    @CreationTimestamp
    LocalDateTime createdAt;
    @CreationTimestamp
    LocalDateTime updatedAt;


}


/* ===== java/com/hau/product_service/entity/ProductImage.java ===== */
package com.hau.product_service.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Data
@Table(name = "product_images")
@NoArgsConstructor
@AllArgsConstructor
public class ProductImage {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @JsonIgnore
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;
    private String url;
}


/* ===== java/com/hau/product_service/entity/Rate.java ===== */
package com.hau.product_service.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;

import java.time.LocalDateTime;

@Entity
@Data
@AllArgsConstructor
@NoArgsConstructor
@Table(name = "rates")
public class Rate {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private int vote;
    private String comment;
    @ManyToOne
    @JoinColumn(name = "product_id", referencedColumnName = "id")
    private Product product;

    @ManyToOne
    @JoinColumn(name = "user_id", referencedColumnName = "id")
    private User user;

    @CreationTimestamp
    LocalDateTime createdAt;
}


/* ===== java/com/hau/product_service/entity/User.java ===== */
package com.hau.product_service.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.List;

@Entity
@Data
@Table(name = "users")
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User {
    @Id
    private Integer id;
    private String username;
    @Version
    private Integer version;
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Rate> rate;
}


/* ===== java/com/hau/product_service/exception/AppException.java ===== */
package com.hau.product_service.exception;

import lombok.Getter;
import lombok.Setter;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;
@Setter
@Getter
public class AppException extends RuntimeException {
    private final HttpStatus httpStatus;
    private final transient Object error;
    private final LocalDateTime timestamp;

    public AppException(HttpStatus httpStatus, String message, Object error) {
        super(message);
        this.httpStatus = httpStatus;
        this.error = error;
        this.timestamp = LocalDateTime.now();
    }
}


/* ===== java/com/hau/product_service/exception/GlobalExceptionHandler.java ===== */
package com.hau.product_service.exception;

import com.hau.product_service.dto.response.ErrorsResponse;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
//import org.springframework.security.authorization.AuthorizationDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;
import org.springframework.web.multipart.support.MissingServletRequestPartException;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {
    // Xử lý ngoại lệ validation
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorsResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            Map<String, String> detail = new HashMap<>();
            detail.put("field", error.getField());
            detail.put("message", error.getDefaultMessage());
            errorDetails.add(detail);
        });
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Lỗi trường dữ liệu", errorDetails, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ DataIntegrityViolationException
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorsResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        Map<String, String> detail = new HashMap<>();
        detail.put("error", ex.getMessage());
        errorDetails.add(detail);
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Vi phạm tính toàn vẹn dữ liệu. Xem 'error' để biết chi tiết.",
                errorDetails,
                LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ tham số không đúng định dạng trong url
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<ErrorsResponse> handleMethodArgumentTypeMismatch(MethodArgumentTypeMismatchException ex) {
        String name = ex.getName();
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Tham số " + name + " không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi truyền sai định dạng tham số trong body request
    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorsResponse> handleHttpMessageNotReadableException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Dữ liệu request không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi khi không tìm thấy tài nguyên
    @ExceptionHandler(AppException.class)
    public ResponseEntity<ErrorsResponse> handleAppException(AppException ex) {
        ErrorsResponse errorResponse =
                new ErrorsResponse(ex.getHttpStatus().value(), ex.getMessage(), ex.getError(), LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, ex.getHttpStatus()); // Trả về HttpStatus từ AppException
    }

    @ExceptionHandler(MissingServletRequestPartException.class)
    public ResponseEntity<ErrorsResponse> handleMissingServletRequestPartException(MissingServletRequestPartException ex) {
        String errorMessage = getString(ex);

        // Tạo đối tượng ErrorsResponse với status 400 và thông báo lỗi tùy chỉnh
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), // Status luôn là 400 cho loại lỗi này
                errorMessage,
                // Bạn có thể đưa tên part bị thiếu vào trường 'error' nếu muốn chi tiết hơn
                // hoặc để null như AppException mặc định nếu error không có thông tin cụ thể
                null, // Hoặc partName
                LocalDateTime.now()
        );

        // Trả về ResponseEntity với status 400
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    private static String getString(MissingServletRequestPartException ex) {
        String partName = ex.getRequestPartName();
        String errorMessage;
        // Tạo thông báo lỗi thân thiện dựa trên tên part bị thiếu
        if ("thumbnail".equals(partName)) {
            errorMessage = "Ảnh thumbnail không được để trống";
        } else if ("images".equals(partName)) {
            errorMessage = "Danh sách ảnh sản phẩm không được để trống";
        }
        else {
            // Trường hợp thiếu part khác không phải thumbnail hoặc images
            errorMessage = "Thiếu phần yêu cầu trong request: " + partName;
        }
        return errorMessage;
    }

    // Xử lý lỗi không có quyền truy cập
//    @ExceptionHandler(AuthorizationDeniedException.class)
//    public ResponseEntity<ErrorsResponse> handleAccessDeniedException() {
//        ErrorsResponse errorResponse = new ErrorsResponse(
//                HttpStatus.FORBIDDEN.value(), "Không có quyền truy cập tài nguyên này", null, LocalDateTime.now());
//        return new ResponseEntity<>(errorResponse, HttpStatus.FORBIDDEN);
//    }

    // Xử lý tất cả các ngoại lệ chưa được xác định
//    @ExceptionHandler(Exception.class)
//    public ResponseEntity<ErrorsResponse> handleAllExceptions() {
//        ErrorsResponse errorResponse = new ErrorsResponse(
//                HttpStatus.INTERNAL_SERVER_ERROR.value(), "Đã có lỗi xảy ra(chưa xác định)", null, LocalDateTime.now());
//        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
//    }

}


/* ===== java/com/hau/product_service/mapper/CategoryMapper.java ===== */
package com.hau.product_service.mapper;

import com.hau.product_service.dto.request.CategoryRequest;
import com.hau.product_service.dto.response.CategoryResponse;
import com.hau.product_service.entity.Category;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

@Mapper(componentModel = "spring")
public interface CategoryMapper {
    CategoryResponse toCategoryResponse(Category category);

    Category toCategory(CategoryRequest categoryRequest);

    Category toCategoryUpdateFromRequest(CategoryRequest categoryRequest, @MappingTarget Category category);
}



/* ===== java/com/hau/product_service/mapper/ProductMapper.java ===== */
package com.hau.product_service.mapper;


import com.hau.product_service.dto.request.ProductRequest;
import com.hau.product_service.dto.response.ProductResponse;
import com.hau.product_service.entity.Category;
import com.hau.product_service.entity.Product;
import com.hau.product_service.entity.ProductImage;
import com.hau.product_service.entity.Rate;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.ReportingPolicy;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.util.CollectionUtils;

import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;


@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface ProductMapper {
    // Define mapping methods here
    @Mapping(target = "productImage", ignore = true)
    Product toProduct(ProductRequest productRequest);

    ProductResponse toProductResponse(Product product);

    @Mapping(source = "productImage", target = "imageUrls")
    @Mapping(source = "categories", target = "categories")
    ProductResponse toProductWithImageResponse(Product product);

    @Mapping(target = "productImage", ignore = true)
    Product updateProductFromRequest(ProductRequest productUpdateRequest, @MappingTarget Product product);


    default List<String> mapProductImagesToUrls(List<ProductImage> images) {
        if (CollectionUtils.isEmpty(images)) { // Sử dụng CollectionUtils cho kiểm tra null và empty
            return Collections.emptyList();
        }
        return images.stream()
                .map(ProductImage::getUrl) // Lấy URL từ mỗi ProductImage
                .collect(Collectors.toList());
    }

    default List<Long> mapCategoriesToIds(List<Category> categories) {
        if (CollectionUtils.isEmpty(categories)) {
            return Collections.emptyList();
        }
        return categories.stream()
                .map(Category::getId)
                .collect(Collectors.toList());
    }

}


/* ===== java/com/hau/product_service/mapper/RateMapper.java ===== */
package com.hau.product_service.mapper;

import com.hau.product_service.dto.request.RateRequest;
import com.hau.product_service.dto.response.RateResponse;
import com.hau.product_service.entity.Rate;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;


@Mapper(componentModel = "spring")
public interface RateMapper {

    @Mapping(target = "productId", source = "product.id")
    @Mapping(target = "userId", source = "user.id")
    RateResponse toRateResponse(Rate rate);

    @Mapping(target = "product", ignore = true)
    @Mapping(target = "user", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "id", ignore = true)
    Rate toRate(RateRequest request);

}


/* ===== java/com/hau/product_service/ProductServiceApplication.java ===== */
package com.hau.product_service;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableFeignClients
@EnableScheduling
public class ProductServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(ProductServiceApplication.class, args);
    }

}


/* ===== java/com/hau/product_service/repository/CategoryRepository.java ===== */
package com.hau.product_service.repository;

import com.hau.product_service.entity.Category;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;


@Repository
public interface CategoryRepository extends JpaRepository<Category, Long> {
    void deleteByParentId(Long id);

    List<Category> findByParentId(Long parentId);


}


/* ===== java/com/hau/product_service/repository/FileServiceClientRepository.java ===== */
package com.hau.product_service.repository;

import com.hau.product_service.config.AuthenticationRequestInterceptor;
import com.hau.product_service.config.FeignMultipartSupportConfig;
import com.hau.product_service.dto.response.ApiResponse;
import com.hau.product_service.dto.response.FileResponse;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.multipart.MultipartFile;

@FeignClient(name = "file-service", url = "${app.file-service.url}",
        configuration = {AuthenticationRequestInterceptor.class, FeignMultipartSupportConfig.class})
public interface FileServiceClientRepository {
    @PostMapping(value = "/file/media", consumes = MediaType.MULTIPART_FORM_DATA_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    ApiResponse<FileResponse> uploadFile(@RequestPart("file") MultipartFile file);

    @DeleteMapping("/file/media/{fileName}")
    ApiResponse<FileResponse> deleteFile(@PathVariable String fileName);
}


/* ===== java/com/hau/product_service/repository/ProductImageRepository.java ===== */
package com.hau.product_service.repository;

import com.hau.product_service.entity.Product;
import com.hau.product_service.entity.ProductImage;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface ProductImageRepository extends JpaRepository<ProductImage, Long> {
    void deleteByProductId(Long id);
    Optional<List<ProductImage>> findByProductId(Long productId);
}


/* ===== java/com/hau/product_service/repository/ProductRepository.java ===== */
package com.hau.product_service.repository;

import com.hau.product_service.dto.request.ProductFilter;
import com.hau.product_service.entity.Product;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    @Query("""
    SELECT DISTINCT p FROM Product p
    JOIN p.categories c
    WHERE (:#{#filter.title} IS NULL OR p.title ILIKE CONCAT('%', :#{#filter.title}, '%'))
      AND (:#{#filter.author} IS NULL OR p.author ILIKE CONCAT('%', :#{#filter.author}, '%'))
      AND (:#{#filter.priceFrom} IS NULL OR p.price >= :#{#filter.priceFrom})
      AND (:#{#filter.priceTo} IS NULL OR p.price <= :#{#filter.priceTo})
      AND (:categoryIds IS NULL OR c.id IN (:categoryIds))
      AND (:#{#filter.averageRateFrom} IS NULL OR p.averageRate >= :#{#filter.averageRateFrom})
""")
    Page<Product> findAllByFilter(@Param("filter") ProductFilter filter,
                                  @Param("categoryIds") List<Long> categoryIds,
                                  Pageable pageable);

    @Query("""
    SELECT DISTINCT p FROM Product p
    JOIN p.categories c
    WHERE (:#{#filter.title} IS NULL OR p.title ILIKE CONCAT('%', :#{#filter.title}, '%'))
      AND (:#{#filter.author} IS NULL OR p.author ILIKE CONCAT('%', :#{#filter.author}, '%'))
      AND (:#{#filter.priceFrom} IS NULL OR p.price >= :#{#filter.priceFrom})
      AND (:#{#filter.priceTo} IS NULL OR p.price <= :#{#filter.priceTo})
      AND (:categoryIds IS NULL OR c.id IN (:categoryIds))
      AND (:#{#filter.averageRateFrom} IS NULL OR p.averageRate >= :#{#filter.averageRateFrom})
      AND (p.active = :active OR :active IS NULL)
""")
    Page<Product> findAllByActiveStatus(@Param("filter") ProductFilter filter,
                                      @Param("categoryIds") List<Long> categoryIds,
                                      Pageable pageable, @Param("active") Boolean active);


    @Query("SELECT p FROM Product p WHERE p.active = true ORDER BY p.discountPercent DESC LIMIT 10 ")
    List<Product> getTopTenBestDiscountProduct();


    @Query("SELECT p FROM Product p WHERE p.active = true ORDER BY p.averageRate DESC LIMIT 10")
    List<Product> getTopTenBestAverageRateProduct();
}


/* ===== java/com/hau/product_service/repository/RateRepository.java ===== */
package com.hau.product_service.repository;


import com.hau.product_service.entity.Rate;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface RateRepository extends JpaRepository<Rate, Long> {
    Page<Rate> findAllByProductId(Long productId, Pageable pageable);
    List<Rate> findAllByProductId(Long productId);
}


/* ===== java/com/hau/product_service/repository/UserRepository.java ===== */
package com.hau.product_service.repository;

import com.hau.product_service.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface UserRepository extends JpaRepository<User, Integer> {
}


/* ===== java/com/hau/product_service/service/CategoryService.java ===== */
package com.hau.product_service.service;


import com.hau.product_service.dto.request.CategoryRequest;
import com.hau.product_service.dto.response.ApiResponse;
import com.hau.product_service.dto.response.CategoryResponse;
import com.hau.product_service.entity.Category;
import com.hau.product_service.exception.AppException;
import com.hau.product_service.mapper.CategoryMapper;
import com.hau.product_service.repository.CategoryRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Service
@RequiredArgsConstructor
public class CategoryService {
    private final CategoryRepository categoryRepository;
    private final CategoryMapper categoryMapper;


    @Transactional
    public void handleCategoryCreated(CategoryRequest request) {
        Category category = categoryMapper.toCategory(request);
        Category savedCategory = categoryRepository.save(category);
        CategoryResponse response = categoryMapper.toCategoryResponse(savedCategory);

        ApiResponse.<CategoryResponse>builder()
                .status(HttpStatus.CREATED.value())
                .message("Tạo danh mục thành công")
                .result(response)
                .timestamp(LocalDateTime.now())
                .build();
    }

    @Transactional
    public void handleCategoryUpdated(Long id, CategoryRequest request) {
        Category existCategory = categoryRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy danh mục", null));
        Category updatedCategory = categoryMapper.toCategoryUpdateFromRequest(request, existCategory);

        Category savedCategory = categoryRepository.save(updatedCategory);
        CategoryResponse response = categoryMapper.toCategoryResponse(savedCategory);

        ApiResponse.<CategoryResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Cập nhật danh mục thành công")
                .result(response)
                .timestamp(LocalDateTime.now())
                .build();
    }

    @Transactional
    public void handleCategoryDeleted(Long id) {
        Category category = categoryRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy danh mục", null));

        categoryRepository.deleteByParentId(id);
        categoryRepository.delete(category);

        ApiResponse.<Void>builder()
                .status(HttpStatus.OK.value())
                .message("Xóa danh mục thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public List<Category> handleCategoryFromProduct(List<Long> categoryIds) {
        Set<Long> uniqueCategoryIds = new HashSet<>(categoryIds);
        List<Category> categories = categoryRepository.findAllById(uniqueCategoryIds);
        if (categories.size() != uniqueCategoryIds.size()) {
            throw new AppException(
                    HttpStatus.NOT_FOUND,
                    "Không tìm thấy một số danh mục trong danh sách",
                    uniqueCategoryIds
            );
        }
        return categories;
    }

    public Set<Long> findAllSubCategoryIds(Long parentId) {
        Set<Long> result = new HashSet<>();
        List<Category> children = categoryRepository.findByParentId(parentId);
        for (Category child : children) {
            result.add(child.getId());
            result.addAll(findAllSubCategoryIds(child.getId()));
        }
        return result;
    }

    public ApiResponse<List<CategoryResponse>> getAllCategories() {
        List<Category> categories = categoryRepository.findAll();
        List<CategoryResponse> responses = categories.stream()
                .map(categoryMapper::toCategoryResponse)
                .toList();

        return ApiResponse.<List<CategoryResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách danh mục thành công")
                .result(responses)
                .timestamp(LocalDateTime.now())
                .build();
    }
}


/* ===== java/com/hau/product_service/service/event/CategoryEventConsumer.java ===== */
package com.hau.product_service.service.event;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.hau.product_service.dto.request.CategoryRequest;
import com.hau.product_service.dto.response.CategoryResponse;
import com.hau.event.dto.CategoryEvent;
import com.hau.product_service.service.CategoryService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@Slf4j
public class CategoryEventConsumer {

    private static final String TOPIC_CATEGORY_PRODUCT_EVENT = "category-product-event";
    private final CategoryService categoryService;
    private final ObjectMapper objectMapper; // Inject ObjectMapper

    @KafkaListener(topics = TOPIC_CATEGORY_PRODUCT_EVENT)
    public void listen(CategoryEvent event) {
        log.info("Received Category Event: {}", event);

        try {
            switch (event.getType()) {
                case "CATEGORY_CREATED":
                    log.info("Handling Category Created event for ID: {}", event.getCategoryId());
                    if (event.getData() != null) {
                        CategoryResponse createdCategory = objectMapper.convertValue(event.getData(), CategoryResponse.class); // Sử dụng convertValue
                        CategoryRequest categoryRequest = convertToCategoryRequest(createdCategory);
                        categoryService.handleCategoryCreated(categoryRequest);
                    } else {
                        log.warn("Category Created event received with no data for ID: {}", event.getCategoryId());
                    }
                    break;

                case "CATEGORY_UPDATED":
                    log.info("Handling Category Updated event for ID: {}", event.getCategoryId());
                    if (event.getData() != null) {
                        CategoryResponse updatedCategory = objectMapper.convertValue(event.getData(), CategoryResponse.class); // Sử dụng convertValue
                        CategoryRequest updatedCategoryRequest = convertToCategoryRequest(updatedCategory);
                        categoryService.handleCategoryUpdated(updatedCategory.getId() ,updatedCategoryRequest);
                    } else {
                        log.warn("Category Updated event received with no data for ID: {}", event.getCategoryId());
                    }
                    break;

                case "CATEGORY_DELETED":
                    log.info("Handling Category Deleted event for ID: {}", event.getCategoryId());
                    categoryService.handleCategoryDeleted(event.getCategoryId());
                    break;

                default:
                    log.warn("Received unknown Category Event type: {}", event.getType());
            }

            if (event.getCategoryId() != null) { // Kiểm tra null cho categoryId trước khi log
                log.info("Successfully processed Category Event for ID: {}", event.getCategoryId());
            } else {
                log.info("Successfully processed Category Event (ID not provided in event)");
            }


        } catch (Exception e) {
            String eventIdLog = (event != null && event.getCategoryId() != null) ? event.getCategoryId().toString() : "N/A";
            log.error("Error processing Category Event for ID {}: {}", eventIdLog, e.getMessage(), e);
        }
    }


    private CategoryRequest convertToCategoryRequest(CategoryResponse category) {
        if (category == null) {
            return null;
        }
        CategoryRequest categoryRequest = new CategoryRequest();
        categoryRequest.setId(category.getId());
        categoryRequest.setName(category.getName());
        categoryRequest.setSlug(category.getSlug());
        categoryRequest.setParentId(category.getParentId());
        return categoryRequest;
    }
}

/* ===== java/com/hau/product_service/service/event/UserEventConsumer.java ===== */
package com.hau.product_service.service.event;

import com.hau.event.dto.UserCreateEvent;
import com.hau.product_service.entity.User;
import com.hau.product_service.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Service;

import java.util.Optional;

@Service
@RequiredArgsConstructor
@Slf4j
public class UserEventConsumer {
    private final UserRepository userRepository;

    @KafkaListener(topics = "user-created-topic")
    public void handleUserCreateEvent(UserCreateEvent userCreateEvent) {
        log.info("Received user create event: {}", userCreateEvent);

        Optional<User> existingUser = userRepository.findById(userCreateEvent.getId());

        if (existingUser.isPresent()) {
            log.warn("User with id {} already exists. Skipping creation for this event.", userCreateEvent.getId());
        } else {
            User newUser = User.builder()
                    .id(userCreateEvent.getId())
                    .username(userCreateEvent.getUsername())
                    .build();
            try {
                userRepository.save(newUser); // Let JPA manage the ID and version
                log.info("Successfully created user with id {}", newUser.getId()); // Log the newly generated ID
            } catch (Exception e) {
                log.error("Failed to save user with id {}. Error: {}", userCreateEvent.getId(), e.getMessage(), e);
                throw new RuntimeException("Failed to save user", e);
            }
        }
    }
}

/* ===== java/com/hau/product_service/service/FileUploadService.java ===== */
package com.hau.product_service.service;

import com.hau.product_service.exception.AppException;
import com.hau.product_service.repository.FileServiceClientRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

@RequiredArgsConstructor
@Service
public class FileUploadService {
    private final FileServiceClientRepository fileServiceClientRepository;

    String uploadFileAndGetUrl(MultipartFile file, String fileTypeDescription) {
        if (file == null || file.isEmpty()) {
            throw new AppException(HttpStatus.BAD_REQUEST, "File " + fileTypeDescription + " không được để trống", null);
        }
        try {
            var fileResponse = fileServiceClientRepository.uploadFile(file);
            if (fileResponse != null && fileResponse.getResult() != null && fileResponse.getResult().getUrl() != null) {
                return fileResponse.getResult().getUrl(); // Return only the relative URL path
            } else {
                throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Không nhận được thông tin hợp lệ từ file-service cho " + fileTypeDescription, null);
            }
        } catch (Exception e) {
            throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi khi tải lên file " + fileTypeDescription, e);
        }
    }
}


/* ===== java/com/hau/product_service/service/ProductImageService.java ===== */
package com.hau.product_service.service;

import com.hau.product_service.entity.Product;
import com.hau.product_service.entity.ProductImage;
import com.hau.product_service.exception.AppException;
import com.hau.product_service.repository.FileServiceClientRepository;
import com.hau.product_service.repository.ProductImageRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.CollectionUtils;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;

@Service
@RequiredArgsConstructor
public class ProductImageService {
    private final ProductImageRepository productImageRepository;
    private final FileUploadService fileUploadService;
    private final FileServiceClientRepository fileServiceClient;

    @Transactional
    public void deleteAllByProductId(Long productId) {
        deleteImage(productId);
        productImageRepository.deleteByProductId(productId);
    }

    @Transactional
    public void createImageByProduct(Product product, List<MultipartFile> images) {
            if(images != null && !images.isEmpty()) {
                for (MultipartFile imageFile : images) {
                    if (imageFile != null && !imageFile.isEmpty()) {
                        try {
                            String imageUrl = fileUploadService.uploadFileAndGetUrl(imageFile, "product image");

                            ProductImage productImage = new ProductImage();
                            productImage.setProduct(product);
                            productImage.setUrl(imageUrl);

                            productImageRepository.save(productImage);
                        } catch (Exception e) {
                            throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi khi tải lên hình ảnh sản phẩm: " + imageFile.getOriginalFilename(), e);
                        }
                    }
                }
            }
    }

    @Transactional
    public void deleteImage(Long productId) {
        List<ProductImage> productImage = productImageRepository.findByProductId(productId)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy ảnh sản phẩm", null));

        try {
            for (ProductImage item : productImage) {
                fileServiceClient.deleteFile(item.getUrl());
            };
        } catch (Exception e) {
            throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Lỗi khi xóa ảnh sản phẩm", e);
        }
    }

}


/* ===== java/com/hau/product_service/service/ProductService.java ===== */
package com.hau.product_service.service;

import com.hau.event.dto.NotificationEvent;
import com.hau.event.dto.ProductEvent;
import com.hau.product_service.entity.Category;
import com.hau.product_service.repository.FileServiceClientRepository;
import com.hau.product_service.converter.StringConverter;
import com.hau.product_service.dto.request.ProductFilter;
import com.hau.product_service.dto.request.ProductRequest;
import com.hau.product_service.dto.response.ApiResponse;
import com.hau.product_service.dto.response.PageResult;
import com.hau.product_service.dto.response.ProductResponse;
import com.hau.product_service.entity.Product;
import com.hau.product_service.exception.AppException;
import com.hau.product_service.mapper.ProductMapper;
import com.hau.product_service.repository.ProductRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;
import org.springframework.web.multipart.MultipartFile;


import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class ProductService {
    private final ProductRepository productRepository;
    private final ProductMapper productMapper;
    private final FileServiceClientRepository fileServiceClientRepository;
    private final ProductImageService productImageService;
    private final FileUploadService fileUploadService;
    private final SlugService slugService;
    private final CategoryService categoryService;
    private final KafkaTemplate<String, Object> kafkaTemplate;
    private final RateService rateService;


    @Value("${app.file.download-prefix}")
    private String fileServiceUrl;

    public ApiResponse<PageResult<ProductResponse>> getAllProduct(ProductFilter filter, Integer pageIndex, Integer pageSize) {
        int page = (pageIndex == null || pageIndex <= 1) ? 0 : pageIndex - 1;

        Sort sort;
        if (filter.getSortDir() != null && !filter.getSortDir().isEmpty()) {
            Sort.Direction direction = "asc".equalsIgnoreCase(filter.getSortDir()) ? Sort.Direction.ASC : Sort.Direction.DESC;
            sort = Sort.by(direction, "price");
        } else {
            sort = Sort.by(Sort.Direction.DESC, "createdAt");
        }

        Pageable pageable = PageRequest.of(page, pageSize, sort);

        List<Long> categoryIds = null;
        if (filter.getCategoryId() != null) {
            Set<Long> allCategoryIds = new HashSet<>();
            allCategoryIds.add(filter.getCategoryId());
            allCategoryIds.addAll(categoryService.findAllSubCategoryIds(filter.getCategoryId()));
            categoryIds = allCategoryIds.stream().toList();
        }

        Page<Product> productPage = productRepository.findAllByFilter(filter, categoryIds, pageable);

        List<ProductResponse> responses = productPage.getContent().stream()
                .map(product -> {
                    ProductResponse res = productMapper.toProductWithImageResponse(product);
                    res.setThumbnail(fileServiceUrl + product.getThumbnail());

                    if (res.getImageUrls() != null) {
                        res.setImageUrls(
                                res.getImageUrls().stream()
                                        .map(url -> fileServiceUrl + url)
                                        .collect(Collectors.toList())
                        );
                    }

                    return res;
                }).toList();

        PageResult<ProductResponse> result = new PageResult<>(
                responses,
                productPage.getNumber() + 1,
                productPage.getSize(),
                productPage.getTotalPages(),
                productPage.getTotalElements(),
                productPage.hasNext(),
                productPage.hasPrevious()
        );

        return ApiResponse.<PageResult<ProductResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách sản phẩm thành công")
                .result(result)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<PageResult<ProductResponse>> getAllProductByActive(ProductFilter filter, Integer pageIndex, Integer pageSize) {
        int page = (pageIndex == null || pageIndex <= 1) ? 0 : pageIndex - 1;

        Sort sort;
        if (filter.getSortDir() != null && !filter.getSortDir().isEmpty()) {
            Sort.Direction direction = "asc".equalsIgnoreCase(filter.getSortDir()) ? Sort.Direction.ASC : Sort.Direction.DESC;
            sort = Sort.by(direction, "price");
        } else {
            sort = Sort.by(Sort.Direction.DESC, "createdAt");
        }

        Pageable pageable = PageRequest.of(page, pageSize, sort);

        List<Long> categoryIds = null;
        if (filter.getCategoryId() != null) {
            Set<Long> allCategoryIds = new HashSet<>();
            allCategoryIds.add(filter.getCategoryId());
            allCategoryIds.addAll(categoryService.findAllSubCategoryIds(filter.getCategoryId()));
            categoryIds = allCategoryIds.stream().toList();
        }

        // Explicitly search for active=true products
        Page<Product> productPage = productRepository.findAllByActiveStatus(filter, categoryIds, pageable, Boolean.TRUE);

        List<ProductResponse> responses = productPage.getContent().stream()
                .map(product -> {
                    ProductResponse res = productMapper.toProductWithImageResponse(product);
                    res.setThumbnail(fileServiceUrl + product.getThumbnail());

                    if (res.getImageUrls() != null) {
                        res.setImageUrls(
                                res.getImageUrls().stream()
                                        .map(url -> fileServiceUrl + url)
                                        .collect(Collectors.toList())
                        );
                    }

                    return res;
                }).toList();

        PageResult<ProductResponse> result = new PageResult<>(
                responses,
                productPage.getNumber() + 1,
                productPage.getSize(),
                productPage.getTotalPages(),
                productPage.getTotalElements(),
                productPage.hasNext(),
                productPage.hasPrevious()
        );

        return ApiResponse.<PageResult<ProductResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách sản phẩm đang hoạt động thành công")
                .result(result)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<List<ProductResponse>> getTopTenProductByBestDiscountPercent() {
        List<Product> products = productRepository.getTopTenBestDiscountProduct();
        List<ProductResponse> responses = products.stream()
                .map(product -> {
                    ProductResponse res = productMapper.toProductWithImageResponse(product);
                    res.setThumbnail(fileServiceUrl + product.getThumbnail());

                    if (res.getImageUrls() != null) {
                        res.setImageUrls(
                                res.getImageUrls().stream()
                                        .map(url -> fileServiceUrl + url)
                                        .collect(Collectors.toList())
                        );
                    }

                    return res;
                }).toList();
        return ApiResponse.<List<ProductResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách sản phẩm thành công")
                .result(responses)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public ApiResponse<List<ProductResponse>> getTopTenProductByAverageRate() {
        List<Product> products = productRepository.getTopTenBestAverageRateProduct();
        List<ProductResponse> responses = products.stream()
                .map(product -> {
                    ProductResponse res = productMapper.toProductWithImageResponse(product);
                    res.setThumbnail(fileServiceUrl + product.getThumbnail());

                    if (res.getImageUrls() != null) {
                        res.setImageUrls(
                                res.getImageUrls().stream()
                                        .map(url -> fileServiceUrl + url)
                                        .collect(Collectors.toList())
                        );
                    }

                    return res;
                }).toList();
        return ApiResponse.<List<ProductResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy danh sách sản phẩm thành công")
                .result(responses)
                .timestamp(LocalDateTime.now())
                .build();
    }

    @Transactional // Ensure atomicity
    public ApiResponse<ProductResponse> createProduct(ProductRequest request, MultipartFile thumbnail, List<MultipartFile> images) {
        if (thumbnail == null || thumbnail.isEmpty()) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Ảnh thumbnail không được để trống", null);
        }

        if (images == null || images.isEmpty()) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Danh sách ảnh sản phẩm không được để trống", null);
        }

        List<Category> categories = categoryService.handleCategoryFromProduct(request.getCategoryIds());

        Product product = productMapper.toProduct(request);
        product.setActive(true);
        product.setCategories(categories);

        product.setDiscountPercent(calculateProductDiscountPercent(product.getPrice(), product.getDiscount()));
        product.setAverageRate(0.0f);
        String thumbnailUrl = fileUploadService.uploadFileAndGetUrl(thumbnail, "thumbnail");
        product.setThumbnail(thumbnailUrl);

        product.setSlug(StringConverter.toSlug(product.getTitle()));

        Product savedProduct = productRepository.save(product);
        Long productId = savedProduct.getId();

        String uniqueSlug = slugService.generateUniqueSlug(savedProduct.getTitle(), productId);
        savedProduct.setSlug(uniqueSlug);

        productImageService.createImageByProduct(savedProduct, images);

        savedProduct.setProductImage(null);
        savedProduct = productRepository.save(savedProduct);

        ProductEvent productEvent = ProductEvent.builder()
                .id(savedProduct.getId())
                .discount(savedProduct.getDiscount())
                .price(savedProduct.getPrice())
                .quantity(savedProduct.getQuantity())
                .title(savedProduct.getTitle())
                .build();
        kafkaTemplate.send("product-create-topic", productEvent);
        ProductResponse productResponse = productMapper.toProductResponse(savedProduct);
        productResponse.setThumbnail(fileServiceUrl + savedProduct.getThumbnail());

        return ApiResponse.<ProductResponse>builder()
                .status(HttpStatus.CREATED.value())
                .message("Thêm sản phẩm thành công")
                .result(productResponse)
                .timestamp(LocalDateTime.now())
                .build();
    }


    // Modified to handle thumbnail and image updates
    @Transactional
    public ApiResponse<ProductResponse> updateProduct(ProductRequest request, Long id, MultipartFile thumbnail, List<MultipartFile> images) {
        Product existProduct = productRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Sản phẩm không tồn tại", null));

        Product product = productMapper.updateProductFromRequest(request, existProduct);

        List<Category> categories = categoryService.handleCategoryFromProduct(request.getCategoryIds());

        if (request.getActive() != null) {
            existProduct.setActive(request.getActive());
        }

        if (thumbnail != null && !thumbnail.isEmpty()) {
            fileServiceClientRepository.deleteFile(existProduct.getThumbnail());
            String newThumbnailUrl = fileUploadService.uploadFileAndGetUrl(thumbnail, "new thumbnail");
            existProduct.setThumbnail(newThumbnailUrl);
        }

        if (!CollectionUtils.isEmpty(images)) {
            productImageService.deleteAllByProductId(id);
            productImageService.createImageByProduct(product, images);
        }

        existProduct.setDiscountPercent(calculateProductDiscountPercent(product.getPrice(), product.getDiscount()));
        existProduct.setSlug(slugService.generateUniqueSlug(product.getTitle(), id));
        existProduct.setCategories(categories);
        Product savedProduct = productRepository.save(existProduct);

        ProductEvent productEvent = ProductEvent.builder()
                .id(savedProduct.getId())
                .discount(savedProduct.getDiscount())
                .price(savedProduct.getPrice())
                .quantity(savedProduct.getQuantity())
                .title(savedProduct.getTitle())
                .build();
        kafkaTemplate.send("product-update-topic", productEvent);

        ProductResponse response = productMapper.toProductResponse(savedProduct);
        response.setThumbnail(savedProduct.getThumbnail());


        return ApiResponse.<ProductResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Cập nhật sản phẩm thành công")
                .result(response)
                .timestamp(LocalDateTime.now())
                .build();
    }



    public ApiResponse<ProductResponse> deleteProduct(Long id) {
        Product product =  productRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Sản phẩm không tồn tại", null));

        productImageService.deleteImage(product.getId());
        fileServiceClientRepository.deleteFile(product.getThumbnail());
        productRepository.deleteById(id);
        return ApiResponse.<ProductResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Xóa sản phẩm thành công")
                .timestamp(LocalDateTime.now())
                .build();
    }



    public ApiResponse<ProductResponse> getProductById(Long productId) {
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Sản phẩm không tồn tại", null));
        ProductResponse response = productMapper.toProductWithImageResponse(product);
        response.setThumbnail(fileServiceUrl + product.getThumbnail());
        List<String> imageUrls = response.getImageUrls();
        for(String item : imageUrls) {
            imageUrls.set(imageUrls.indexOf(item), fileServiceUrl + item);
        }
        return ApiResponse.<ProductResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy sản phẩm thành công")
                .result(response)
                .timestamp(LocalDateTime.now())
                .build();
    }


    public void updateProductQuantity(NotificationEvent notificationEvent) {
        Map<String, Object> params = notificationEvent.getParams();
        Object orderProducts = params.get("orderProducts");

        if (orderProducts instanceof List<?> orderProductList) {
            for (Object item : orderProductList) {
                if (item instanceof Map<?, ?> productMap) {
                    log.info("Product map: {}", productMap);

                    Object productIdObj = productMap.get("productId");
                    if (!(productIdObj instanceof Integer)) {
                        log.error("productId không phải là Integer.  Value: {}", productIdObj);
                        continue;
                    }
                    Long productId = ((Integer) productIdObj).longValue();


                    Object quantityObj = productMap.get("quantity");
                    if (!(quantityObj instanceof Integer)) {
                        log.error("quantity không phải là Integer. Value: {}", quantityObj);
                        continue;
                    }
                    int quantity = (Integer) quantityObj;


                    try {
                        Product product = productRepository.findById(productId)
                                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Sản phẩm không tồn tại", null));
                        product.setQuantity(product.getQuantity() - quantity);
                        productRepository.save(product);
                    } catch (AppException e) {
                        log.error("Lỗi khi xử lý sản phẩm với productId {}: {}", productId, e.getMessage());
                    }
                }
            }
        } else {
            log.warn("orderProducts không phải là List hoặc null");
        }
    }

    public Double calculateProductDiscountPercent(Integer price, Integer discount) {
        if (price == null || discount == null || price <= 0) {
            return 0.0;
        }
        return 100 - ((double) discount / price) * 100;
    }
}


/* ===== java/com/hau/product_service/service/RateService.java ===== */
package com.hau.product_service.service;

import com.hau.product_service.dto.request.RateRequest;
import com.hau.product_service.dto.response.ApiResponse;
import com.hau.product_service.dto.response.PageResult;
import com.hau.product_service.dto.response.RateResponse;
import com.hau.product_service.entity.Product;
import com.hau.product_service.entity.Rate;
import com.hau.product_service.entity.User;
import com.hau.product_service.exception.AppException;
import com.hau.product_service.mapper.RateMapper;
import com.hau.product_service.repository.ProductRepository;
import com.hau.product_service.repository.RateRepository;
import com.hau.product_service.repository.UserRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

@Service
@RequiredArgsConstructor
public class RateService {
    private final RateRepository rateRepository;
    private final RateMapper rateMapper;
    private final ProductRepository productRepository;
    private final UserRepository userRepository;

    public ApiResponse<PageResult<RateResponse>> getAllRate(Integer pageIndex, Integer pageSize) {
        int page = (pageIndex == null || pageIndex <= 1) ? 0 : pageIndex - 1;
        Pageable pageable = PageRequest.of(page, pageSize);

        Page<Rate> rates = rateRepository.findAll(pageable);

        List<RateResponse> rateResponses = rates.getContent().stream()
                .map(rateMapper::toRateResponse)
                .toList();

        PageResult<RateResponse> result = new PageResult<>(
                rateResponses,
                rates.getNumber() + 1,
                rates.getSize(),
                rates.getTotalPages(),
                rates.getTotalElements(),
                rates.hasNext(),
                rates.hasPrevious()
        );


        return ApiResponse.<PageResult<RateResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Get all rates successfully")
                .result(result)
                .build();
    }

    public ApiResponse<RateResponse> getRateById(Long id) {
        Rate rate = rateRepository.findById(id).orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy đánh giá ", "id = " + id));
        RateResponse rateResponse = rateMapper.toRateResponse(rate);
        return ApiResponse.<RateResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy đánh giá thành công")
                .result(rateResponse)
                .build();
    }

    public ApiResponse<PageResult<RateResponse>> getRateByProductId(Long productId, Integer pageIndex, Integer pageSize) {
        int page = (pageIndex == null || pageIndex <= 1) ? 0 : pageIndex - 1;
        Pageable pageable = PageRequest.of(page, pageSize);

        Page<Rate> rates = rateRepository.findAllByProductId(productId, pageable);

        List<RateResponse> rateResponses = rates.getContent().stream()
                .map(rateMapper::toRateResponse)
                .toList();

        PageResult<RateResponse> result = new PageResult<>(
                rateResponses,
                rates.getNumber() + 1,
                rates.getSize(),
                rates.getTotalPages(),
                rates.getTotalElements(),
                rates.hasNext(),
                rates.hasPrevious()
        );

        return ApiResponse.<PageResult<RateResponse>>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy đánh giá thành công")
                .result(result)
                .build();
    }

    @Transactional
    public ApiResponse<RateResponse> createRate(RateRequest request) {
        Product product = productRepository.findById(request.getProductId())
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy sản phẩm", "id = " + request.getProductId()));
        Integer userId = Integer.valueOf(SecurityContextHolder.getContext().getAuthentication().getName());
        User user =  userRepository.findById(userId)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy người dùng", "id = " + userId));
        Rate newRate = rateMapper.toRate(request);

        newRate.setProduct(product);
        newRate.setUser(user);
        Rate savedRate = rateRepository.save(newRate);
        Float averageRate = calculateAverageRate(newRate.getProduct().getId());
        product.setAverageRate(averageRate);
        productRepository.save(product);

        RateResponse rateResponse = rateMapper.toRateResponse(savedRate);

        return ApiResponse.<RateResponse>builder()
                .status(HttpStatus.CREATED.value())
                .message("Tạo đánh giá thành công")
                .result(rateResponse)
                .build();
    }

    @Transactional
    public ApiResponse<RateResponse> removeRate(Long id) {
        Rate rate = rateRepository.findById(id)
                .orElseThrow(() -> new AppException(HttpStatus.NOT_FOUND, "Không tìm thấy đánh giá", "id = " + id));
        rateRepository.delete(rate);
        Product product = rate.getProduct();
        Float averageRate = calculateAverageRate(product.getId());
        product.setAverageRate(averageRate);
        productRepository.save(product);
        return ApiResponse.<RateResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Xóa đánh giá thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public Float calculateAverageRate(Long productId) {
        List<Rate> rates = rateRepository.findAllByProductId(productId);

        float totalRate = 0f;
        for (Rate rate : rates) {
            totalRate += rate.getVote();
        }
        return Float.valueOf(String.format("%.1f", totalRate / rates.size())) ;
    }

}


/* ===== java/com/hau/product_service/service/SlugService.java ===== */
package com.hau.product_service.service;

import com.hau.product_service.converter.StringConverter;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class SlugService {
    String generateUniqueSlug(String title, Long productId) {
        String baseSlug = StringConverter.toSlug(title);
        return baseSlug + "-" + productId;
    }

}


